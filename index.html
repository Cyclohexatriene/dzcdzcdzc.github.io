<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cyclohexatriene.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="万里长征人未还">
<meta property="og:type" content="website">
<meta property="og:title" content="环己三烯的冬眠舱">
<meta property="og:url" content="http://cyclohexatriene.github.io/index.html">
<meta property="og:site_name" content="环己三烯的冬眠舱">
<meta property="og:description" content="万里长征人未还">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="环己三烯">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cyclohexatriene.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>环己三烯的冬眠舱</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">环己三烯的冬眠舱</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天天网抑云，偶尔读点书。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-comment-board">

    <a href="/comment-board" rel="section">留言板</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2024/03/28/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/28/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">JVM 垃圾收集器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-28 14:19:20" itemprop="dateCreated datePublished" datetime="2024-03-28T14:19:20+08:00">2024-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-30 17:24:52" itemprop="dateModified" datetime="2024-03-30T17:24:52+08:00">2024-03-30</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>
</blockquote>
<h3 id="哪些对象需要回收？"><a href="#哪些对象需要回收？" class="headerlink" title="哪些对象需要回收？"></a>哪些对象需要回收？</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>在对象中添加一个引用计数器用于记录该对象的引用数量。当某对象的引用数量归零时就可以回收这个对象了。</p>
<p><strong>优势：</strong>实现简单，判定效率高。简单到面试手撕代码时会考<a href="https://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/#2-%E8%83%BD%E4%B8%8D%E8%83%BD%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAshared-ptr%EF%BC%9F">“使用引用计数算法来实现一个C++智能指针”</a>。</p>
<p><strong>劣势：</strong>有大量的例外情况需要考虑，例如两个对象互相引用时引用计数器就永远不会为0，导致这两个对象永远不会被回收。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Java的内存管理系统是通过可达性分析算法来判定对象是否存活的。该算法从一组被称为“GC Roots”的根对象作为起始节点集开始，顺着引用链向下搜索，如果某对象与GC Roots之间没有任何引用链相连，说明该对象不可能再被使用，即可以被回收。</p>
<p>GC Roots主要包括两栈两方法：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<p>和由具体的垃圾收集器临时性加入的其他对象。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><h4 id="基础假说"><a href="#基础假说" class="headerlink" title="基础假说"></a>基础假说</h4><p>分代收集理论建立在两个假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。（IBM公司实测，有98%的对象熬不过第一轮GC）</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
<p>根据以上假说，收集器设计者一般会将Java堆划分为新生代和老年代，对象在新生代区域创建，若其在若干次GC后依然存活便可晋升至老年代。每次GC可以只对新生代进行回收，也可只对老年代进行回收，以此划分为只回收新生代的“Minor GC”，只回收老年代的“Major GC”和回收整个Java堆的“Full GC”。</p>
<p>由于不同区域的对象有不同的特征，所以可以针对不同区域设计针对性的垃圾收集算法。</p>
<p>PS：Major GC只回收老年代的说法存疑，因为很多Major GC是由Minor GC触发的，所以Major GC通常跟Full GC是等价的。但是个人觉得单从分类上还是可以这么说，不用太钻牛角尖。</p>
<p>PPS：还有一种Mixed GC，目标是收集整个新生代和部分老年代，目前只有G1收集器会有这种行为。</p>
<h4 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h4><p>假如现在要进行一次Minor GC，由于新生代的对象可能会被老年代中的对象引用，所以GC选择的GC Roots除了新生代本身的GC Roots外，还需要扫描整个老年代中的对象，来确保可达性分析结果的正确性，这就造成了很大的性能负担。于是引入第三条经验法则：</p>
<ol start="3">
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>如果某个新生代对象被老年代对象引用，由于老年代对象不容易被回收，所以该新生代对象也很容易就能进入老年代，这样就不存在跨代引用了。</p>
<p>所以我们没必要为了少量的跨代引用去扫描整个老年代，只需要在新生代上维护一个全局的“记忆集”，记忆集会把老年代划分为若干小块，用于标记老年代的哪些块的内存存在跨代引用，此后在发生Minor GC的时候，只需要把被标记的老年代内存块中的对象加入到GC Roots里扫描就可以了。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>顾名思义，标记-清除算法有标记和清除两个阶段。首先标记出所有需要回收（或不需要回收）的对象，然后回收被标记（或未被标记）的对象。</p>
<p><strong>缺点：</strong>①执行效率不稳定，如果有大量需要清除的对象就会花很多时间。②简单清除之后会产生大量不连续的内存碎片，时间久了会影响较大对象的内存分配。</p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>标记-复制算法将内存按容量划分为大小相等的两块，每次只使用其中一块。在GC时，把还存活的对象复制到另一块，然后一次性清理掉一整块内存。</p>
<p><strong>优点：</strong>①只需要复制存活对象，在存活对象较少时效率比较高。所以适合用于回收新生代。②不用考虑内存碎片问题。</p>
<p><strong>缺点：</strong>浪费了一半内存。</p>
<p><strong>优化：</strong>不需要按1:1的比例划分，如Appel式回收。</p>
<p>Appel式回收把新生代分为一块较大的Eden（伊甸园）空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor空间。GC时，将Eden和Survivor中仍然存活的对象复制到空的Survivor空间里，然后直接清理Eden和刚用完的Survivor空间。HotSpot虚拟机默认Eden和两块Survivor的空间比例是8:1:1，即每次新生代内存中可用内存空间为整个新生代内存容量的90%。这样的内存浪费就比较可以接受了。</p>
<p>如果Survivor空间不足以容纳一次Minor GC后存活的所有对象，那这些对象就全部直接进入老年代，也就是说此时新生代将不包括任何存活对象。如果老年代空间也不够用了，虚拟机就会触发一次Major GC以尝试释放内存。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法在标记完毕后，让所有存活的对象向内存空间的一端移动，然后清除掉边界以外的内存。</p>
<p><strong>优点：</strong>①不存在内存浪费，也不用额外空间担保，适合用于老年代。②不会产生内存碎片。</p>
<p><strong>缺点：</strong>①老年代往往会有大量对象存活，整理时需要移动这些存活对象，必须全程暂停用户程序（直到后来发明了移动时不用暂停的垃圾收集器）。</p>
<p>对于针对老年代的垃圾回收，标记-清除算法只需要清除少量的非存活对象，不需要长时间暂停用户程序，但会带来大量的内存碎片，采用该算法可以带来较低的时延，但同时也会有较低的吞吐量；标记-整理算法需要移动大量的存活对象，所以需要更久地暂停用户程序，但可以消除内存碎片，采用该算法会有较高的时延，但同时也会有较高的吞吐量。当然，也可以把两者结合起来，在平时多数时间使用标记-清除算法，直到内存碎片太多太碎，影响到对象分配时，再进行一次标记-整理。</p>
<h3 id="一些经典的垃圾收集器"><a href="#一些经典的垃圾收集器" class="headerlink" title="一些经典的垃圾收集器"></a>一些经典的垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>顾名思义，Serial收集器是一个单线程工作的收集器。不仅是本身单线程，还得在工作时暂停所有其他用户线程。</p>
<p>Serial收集器在新生代采用标记-复制算法，有Serial Old收集器作为老年代收集器与之配套。</p>
<p>虽然要打断用户线程，但是对于内存资源受限的环境，它足够简单而高效，跟其他的花里胡哨的高级收集器相比，它的额外内存消耗最少，也没有线程交互的开销。针对少量的新生代垃圾，Serial收集器的停顿时间完全可控。所以Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old收集器采用标记-整理算法，是Serial收集器的老年代版本。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器是Serial收集器的多线程并行版本。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。吞吐量指的是运行用户代码的时间与处理器总消耗时间的比值。它可以通过参数-XX:MaxGCPauseMillis来设置内存回收允许的时间。垃圾收集停顿时间缩短的代价是牺牲新生代空间（收集300MB肯定比收集500MB快）和吞吐量（少量多次收集，总收集时间变长，吞吐量就降低了）换的。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器全名叫Concurrent Mark Sweep，顾名思义就是可以并发地完成标记，而且是标记-清除算法。它的设计目标是获取最短的回收停顿时间。整个回收过程分为四个步骤：</p>
<ol>
<li>初始标记（仅仅只是标记一下GC Roots能直接关联到的对象，虽然<strong>需要停顿</strong>但是速度很快）</li>
<li>并发标记</li>
<li>重新标记（修正并发标记阶段用户修改的引用关系，<strong>需要停顿</strong>，但时间依然远比并发标记短）</li>
<li>并发清除（直接清除标记为死亡的对象，不需要移动存活对象，所以可与用户线程并发）</li>
</ol>
<p><strong>优点：</strong>大大降低了GC时对用户线程的停顿时间。</p>
<p><strong>缺点：</strong>①会占用一部分CPU核心，在CPU核心数量不多的设备上运行时会严重影响用户进程。②在清理垃圾的同时用户线程依然在运行，还可能需要更多的内存，所以不能在内存彻底耗尽时才触发GC，需要留有余量。如果余量不足，就会出现并发失败，JVM只能改用停顿时间较长的Serial Old来重新进行GC。③会产生内存碎片，需要定期整理。</p>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>Garbage First收集器简称G1收集器，是一款主要面向服务端应用的垃圾收集器。G1收集器将内存空间划分为若干个大小相等的Region，每个Region都可以当成新生代的Eden空间、Survivor空间或者老年代空间使用。还有一类专门用于处理大对象的Humongous Region，G1一般将这种Region视作老年代的一部分处理。通过这种设计，G1收集器可以避免每次GC都回收像整个新生代这么大的内存空间，而是选择最有性价比的Region进行回收，使得停顿时间可控。回收时，G1收集器采用标记-复制算法，整个回收过程大致可划分为四个步骤：</p>
<ol>
<li>初始标记（<strong>需要停顿</strong>）</li>
<li>并发标记</li>
<li>最终标记（<strong>需要停顿</strong>）</li>
<li>筛选回收（把选中Region的存活对象复制到空Region里，然后清理掉整个旧Region。由于涉及存活对象的移动，所以<strong>需要停顿</strong>。）</li>
</ol>
<p><strong>优点：</strong>①可以指定最大停顿时间，在不同应用场景中取得吞吐量和延迟的最佳平衡。②不会产生内存碎片。</p>
<p><strong>缺点：</strong>①需要占用更多额外内存来维护跨Region引用的关系。②存在和CMS收集器一样的并发失败问题。</p>
<h4 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h4><p>Shenandoah收集器像是G1收集的下一代继承者，二者之间共享了一部分实现代码。Shenandoah收集器的目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内。</p>
<p>Shenandoah收集器也是使用基于Region的堆内存布局，也是优先处理回收价值最大的Region，但是Shenandoah收集器支持并发的整理算法，默认不使用分代收集，且改用连接矩阵来代替G1中耗费大量内存和计算资源去维护的记忆集。</p>
<p>Shenandoah收集器的工作过程大致可划分为九个阶段：</p>
<ul>
<li>初始标记（<strong>需要停顿</strong>）</li>
<li>并发标记</li>
<li>最终标记（<strong>需要停顿</strong>）</li>
<li>并发清理（清理整个Region里只有死亡对象的Region）</li>
<li>并发回收（通过读屏障和转发指针来实现可与用户线程并发的对象移动）</li>
<li>初始引用更新（确保并发回收阶段中的回收线程均已完成对象移动任务，<strong>需要短暂停顿</strong>）</li>
<li>并发引用更新</li>
<li>最终引用更新（修正GC Roots中的引用，<strong>需要停顿</strong>）</li>
<li>并发清理（清理掉所有完成复制的Region）</li>
</ul>
<p>为了实现收集器对存活对象的复制和用户线程对存活对象的访问这两件事的并发，Shenandoah回收器在对象头引入了转发指针“Brooks Pointer”。在不处于并发移动的状态下，这个转发指针指向对象自己。</p>
<p>但是如果不做任何保护措施的话，转发指针可能会发生并发问题。例如：</p>
<ol>
<li>收集器线程复制了新的对象副本</li>
<li>用户线程更新对象的某个字段</li>
<li>收集器线程更新转发指针的引用值为新副本地址</li>
</ol>
<p>如果事件2在事件1和3之间发生的话，线程2的修改就仅仅在旧对象上，无法对新对象生效。而Shenandoah收集器则是通过CAS原子操作来保证并发时对象的访问正确性的。</p>
<blockquote>
<p>CAS：Compare And Swap，解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
</blockquote>
<p>这块内容存疑，作者没说明CAS具体是在什么操作上应用的。如果是在更新转发指针时使用CAS的话，根据我的理解，CAS的作用是可以在<strong>多个线程同时修改一个变量</strong>的时候保证并发安全，但是这里用户线程只是读取转发指针的引用值，只有收集器线程在修改转发指针的引用值。这么说来，CAS应该不能处理前面提到的那个问题。在这块内容上还有些细节作者在书中没有细说，想了一个下午也没想明白，暂且搁置。如果有人偶然看到这里，欢迎与我讨论。</p>
<p><strong>优点：</strong>并发收集，可以实现很低的延迟。</p>
<p><strong>缺点：</strong>需要使用读写屏障，吞吐量会受到影响。</p>
<h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>ZGC收集器的设计目标和Shenandoah收集器是高度相似的，但实现思路却差异显著。</p>
<p>ZGC也是采用基于Region的堆内存布局，分为小型、中型、大型三类。</p>
<p>ZGC引入了“染色指针”。染色指针是一种直接将少量额外信息存储在指针上的技术。因为在64位系统中，理论上可以访问2^64B &#x3D; 16EB的内存，但由于需求、性能和成本等考虑，现有的硬件架构和操作系统不会使用全部64位来寻址内存，例如Linux则使用了其中的46位。而ZGC的染色指针技术则从这46位里再抽了高4位出来存储四个标志信息，通过这四个标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入重分配集等状态。由于占用了这4位，所以ZGC能管理的内存不能超过2^42B &#x3D; 4TB。染色指针使用虚拟内存映射来寻址，保证无论染色位的情况如何，都能把指针映射到相同的物理内存。</p>
<p> ZGC收集器的工作过程大致可划分为四个大阶段，四个大阶段都是可并发执行的，只有两个阶段中间会存在短暂的停顿，如类似G1的初始标记和最终标记。</p>
<ol>
<li>并发标记（与G1和Shenandoah的标记类似，不过是通过染色指针来代替直接在对象上标记）</li>
<li>并发预备重分配（根据标记结和“特定的查询条件”统计得出本次收集过程要清理哪些Region，组成重分配集）</li>
<li>并发重分配（把重分配集中的存活对象复制到新的Region中）</li>
<li>并发重映射（修正整个堆中指向旧对象的所有引用）</li>
</ol>
<p>ZGC重分配集和G1回收集的区别：G1收集器实现了分代回收功能，回收行为可能局限于新生代或老年代，选出的回收集也就是从局部选出的。由于分代，所以需要维护记忆集来处理跨代引用问题。ZGC收集器没有实现分代回收功能，不需要维护记忆集，省下来的时间用来进行全堆扫描了，重分配集也是从整个堆选出来的。</p>
<p>在并发重分配阶段，ZGC会为每个旧Region维护一个转发表，记录旧对象和新对象的转发关系。用户线程可以直接从染色指针上看出旧对象是否在重分配集里，如果用户线程发现旧对象在重分配集里，就会立即根据转发表将访问转发到新对象上（通过内存屏障实现），<strong>同时修正更新该引用的值，使其直接指向新对象，这种行为称作指针的“自愈”</strong>。</p>
<p>由于指针可以自愈，并发重映射阶段并不需要迫切地被执行，清理旧对象的引用主要是为了减少自愈前唯一的那一次转发，以及清理完毕后可以释放转发表。因此，ZGC把并发重映射阶段的工作合并到了下一次GC的并发标记阶段里完成，两次操作只需要在同一次遍历对象图中完成即可。</p>
<h3 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h3><h4 id="没事听点歌（Lynyrd-Skynyrd-Free-Bird）"><a href="#没事听点歌（Lynyrd-Skynyrd-Free-Bird）" class="headerlink" title="没事听点歌（Lynyrd Skynyrd - Free Bird）"></a>没事听点歌（Lynyrd Skynyrd - Free Bird）</h4><audio controls>
    <source src="https://cyclohexatriene.github.io/music/Free Bird.mp3" type="audio/mpeg">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2024/03/25/WSL2-CLion-%E7%BC%96%E8%AF%91%E5%B9%B6%E8%B0%83%E8%AF%95JDK12%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/WSL2-CLion-%E7%BC%96%E8%AF%91%E5%B9%B6%E8%B0%83%E8%AF%95JDK12%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">WSL2 + CLion 编译并调试JDK12源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-25 13:39:25 / 修改时间：15:37:05" itemprop="dateCreated datePublished" datetime="2024-03-25T13:39:25+08:00">2024-03-25</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近打算开始读《深入理解Java虚拟机》，作者在第一章推荐读者自己编译一份JDK，并使用CLion来阅读和调试源码。由于笔者没有原生的Linux或MacOS环境，只能使用WSL2来平替。在配置过程中踩了一些坑，遂记录一下，没准以后会有人需要。</p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>源码的仓库在<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk/jdk12">https://hg.openjdk.java.net/jdk/jdk12</a> ，点击左边的browse就是源码的文件目录了。本来想直接在WSL里使用wget来下载.tar.gz文件，发现下载不动，于是选择使用Windows的浏览器直接下载.tar.gz，再从文件系统里找到WSL的目录复制进去。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/1.png"></p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/2.png"></p>
<p>然后从WSL里打开对应目录就能找到源码文件，虽然多了一个不知道有什么用的Identifier（猜测跟Windows的文件系统有关），但是并不影响源码的解压。使用tar指令解压压缩包即可获得源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf jdk12-06222165c35f.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://cyclohexatriene.github.io/images/JDK/3.png"></p>
<h3 id="构建编译环境"><a href="#构建编译环境" class="headerlink" title="构建编译环境"></a>构建编译环境</h3><p>不得不说Linux下配环境确实比Windows方便不少。</p>
<p>在开始之前建议先更新一下软件源：<code>sudo apt-get update</code></p>
<h4 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<h4 id="安装一些依赖库"><a href="#安装一些依赖库" class="headerlink" title="安装一些依赖库"></a>安装一些依赖库</h4><p><img src="https://cyclohexatriene.github.io/images/JDK/4.jpg"></p>
<p>这个表是书的作者提供的，实际操作的时候发现我的环境还缺了一个ZIPEXE（提示<code>Could not find required tool for ZIPEXE</code>），安装后就好了：<code>sudo apt-get install zip</code></p>
<h4 id="安装Bootstrap-JDK"><a href="#安装Bootstrap-JDK" class="headerlink" title="安装Bootstrap JDK"></a>安装Bootstrap JDK</h4><blockquote>
<p>编译大版本号为N的JDK时需要用到另一个大版本号至少为N-1的已经编译好的JDK。因为OpenJDK只有部分代码使用C&#x2F;C++编写，更多的是使用Java编写的，所以需要另一个编译期可用的JDK来编译这部分代码，官方称这个JDK为“Bootstrap JDK”</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<h3 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h3><p>源码目录中有一个叫<code>configure</code>的bash文件，提供检查依赖项是否齐全和设置参数等功能。作者给出的配置指令是<code>bash configure --enable-debug --with-jvm-variants=server</code>，配置完毕后使用<code>make images</code>进行编译。但是实际上我遇到了两个问题。</p>
<h4 id="没有jre目录"><a href="#没有jre目录" class="headerlink" title="没有jre目录"></a>没有jre目录</h4><p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误的路径元素 &quot;/usr/lib/jvm/java-17-openjdk-amd64/jre/lib&quot;: 没有这种文件或目录</span><br></pre></td></tr></table></figure>

<p>我顺着这个目录找下去，发现我只有<code>/usr/lib/jvm/java-17-openjdk-amd64</code>目录，因为从JDK11开始jre已经不是默认安装了。我们可以手动生成一个（需要切换到需要生成jre的JDK的目录）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/jlink --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<p>这里需要调用的应该是上面提到的Bootstrap JDK，但是我环境变量之前配过JDK17，所以这里就调用了JDK17，而不是新下载的JDK11。</p>
<h4 id="调用strncpy产生的奇怪问题"><a href="#调用strncpy产生的奇怪问题" class="headerlink" title="调用strncpy产生的奇怪问题"></a>调用strncpy产生的奇怪问题</h4><p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== Output from failing command(s) repeated here ===</span><br><span class="line">* For target hotspot_variant-server_libjvm_objs_arguments.o:</span><br><span class="line">In file included from /usr/include/string.h:495,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/globalDefinitions_gcc.hpp:35,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/globalDefinitions.hpp:32,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/align.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/runtime/globals.hpp:29,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/memory/allocation.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/classfile/classLoaderData.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/precompiled/precompiled.hpp:34:</span><br><span class="line">In function ‘char* strncpy(char*, const char*, size_t)’,</span><br><span class="line">    inlined from ‘static jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs*, bool*, JVMFlag::Flags)’ at /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/runtime/arguments.cpp:2472:29:</span><br><span class="line">/usr/include/x86_64-linux-gnu/bits/string_fortified.h:106:34: error: ‘char* __builtin_strncpy(char*, const char*, long unsigned int)’ output truncated before terminating nul copying as many bytes from a string as its length [-Werror=stringop-truncation]</span><br><span class="line">  106 |   return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));</span><br><span class="line">   ... (rest of output omitted)</span><br><span class="line"></span><br><span class="line">* All command lines available in /home/dzc/JVM/jdk12-06222165c35f/build/linux-x86_64-server-fastdebug/make-support/failure-logs.</span><br><span class="line">=== End of repeated output ===</span><br></pre></td></tr></table></figure>

<p>说实话没怎么看懂，似乎和什么字符串被截断有关，在网上查了很久都没找到有类似情况的。然后发现官方有在源码目录里附上docs，于是不抱希望地点开查看，在<code>building.html</code>的<code>Troubleshooting</code>里找到了这样一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hint: If caused by a warning, try configure --disable-warnings-as-errors</span><br></pre></td></tr></table></figure>

<p>又想到报错信息里有这么一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1plus: all warnings being treated as errors</span><br></pre></td></tr></table></figure>

<p>于是清除原来的配置之后重新配置，添加不把warnings视作errors的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist-clean</span><br><span class="line">bash configure --enable-debug --with-jvm-variants=server --disable-warnings-as-errors</span><br></pre></td></tr></table></figure>

<p>之后再<code>make images</code>就编译成功了。进入<code>build/配置名称/jdk/bin</code>目录下执行<code>./java -version</code>可以看到版本信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;12-internal&quot; 2019-03-19</span><br><span class="line">OpenJDK Runtime Environment (fastdebug build 12-internal+0-adhoc.dzc.jdk12-06222165c35f)</span><br><span class="line">OpenJDK 64-Bit Server VM (fastdebug build 12-internal+0-adhoc.dzc.jdk12-06222165c35f, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="在CLion中进行源码调试"><a href="#在CLion中进行源码调试" class="headerlink" title="在CLion中进行源码调试"></a>在CLion中进行源码调试</h3><p>由于不是原生的Linux环境，我在尝试从源码导入CMake项目的时候也卡了很久，最后按照<a target="_blank" rel="noopener" href="https://lin1997.github.io/2020/07/19/debug-openjdk-on-ubuntu.html">这篇文章</a>的流程完成了配置。</p>
<h4 id="CLion连接Ubuntu"><a href="#CLion连接Ubuntu" class="headerlink" title="CLion连接Ubuntu"></a>CLion连接Ubuntu</h4><p>打开CLion，左侧选择WSL，再选择New Project，然后根据指引操作。选择文件目录时选择刚才的JDK源码目录（即解压之后得到的目录）。之后CLion会自动开始在WSL里下载服务端并启动。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/5.png"></p>
<h4 id="创建自定义Build-Target"><a href="#创建自定义Build-Target" class="headerlink" title="创建自定义Build Target"></a>创建自定义Build Target</h4><p>点击IDE右上角的齿轮，选择Settings，左边找到Custom Build Targets，点击“+”新建一个Build Target，Toolchain选择Default，并填写Name。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/6.png"></p>
<p>然后点击Build或Clean右边的“…”，新建两个External Tools：</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/7.png"></p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/8.png"></p>
<p>新建完后把make填到Build里，make clean填到Clean里。</p>
<h4 id="创建自定义Run-x2F-Debug-configuration"><a href="#创建自定义Run-x2F-Debug-configuration" class="headerlink" title="创建自定义Run&#x2F;Debug configuration"></a>创建自定义Run&#x2F;Debug configuration</h4><p>点击这个位置的Edit Configurations，并新建一个Custom Build Application。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/9.png"></p>
<p>Target选择刚才自定义的Build Target，Executable选择编译出来的JDK（刚才查看version时执行的那个程序），Program arguments可以先填一个-version测试一下。下面的build记得删掉。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/10.png"></p>
<p>至此配置完成。</p>
<h4 id="测试运行、打断点"><a href="#测试运行、打断点" class="headerlink" title="测试运行、打断点"></a>测试运行、打断点</h4><p>完成以上配置之后，右上角的Run和Debug应该已经变成绿色的了。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/11.png"></p>
<p>点击Run，可以发现输出了JDK的版本信息。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/12.png"></p>
<p>接下来测试断点功能。JVM的入口函数是<code>src/java.base/share/native/libjli/java.c</code>文件下的<code>JavaMain(void * _args)</code>函数。在这个函数打上断点后点击右上角的Debug，程序就会在断点处停止运行，并看到我们传入的参数信息。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/13.png"></p>
<hr>
<h3 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h3><h4 id="Long-time-no-see"><a href="#Long-time-no-see" class="headerlink" title="Long time no see"></a>Long time no see</h4><p>又有快一年没更新了。去年暑假在上海实习，回来之后彻底从e人变成了i人，没事就喜欢宅着。顺利拿了转正offer，人生的下一个阶段就是在上海当牛马了。现在又开始觉得自己没有什么可以失去的了，孩子我无敌了。上个学期一直在摆烂，最近肝完了毕业论文的初稿，趁着还算是有一点点学习的状态学一点以后工作可能用得上的东西。希望这段时间能经常更新吧。</p>
<h4 id="没事听点歌（橘子海-夏日漱石）"><a href="#没事听点歌（橘子海-夏日漱石）" class="headerlink" title="没事听点歌（橘子海 - 夏日漱石）"></a>没事听点歌（橘子海 - 夏日漱石）</h4><audio controls>
    <source src="https://cyclohexatriene.github.io/music/夏日漱石.mp3" type="audio/mpeg">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/06/26/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/26/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Spring Boot快速上手指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-26 20:54:58 / 修改时间：22:18:56" itemprop="dateCreated datePublished" datetime="2023-06-26T20:54:58+08:00">2023-06-26</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>本文是 <a target="_blank" rel="noopener" href="https://spring.io/quickstart">Spring官方提供的教程</a> 的中文译文。中文互联网上能查的教程质量都不怎么样（起码对于完全0基础的萌新来说），有的没头没尾的，有的细节上（比如JDK版本和Maven的pom.xml文件中的父项目版本号不兼容等）没说清楚，给萌新留下了巨大的坑。在踩了一个下午 + 半个晚上的坑之后，笔者终于下定决心去Spring官网啃官方的英文教程。虽然很不想看英文，但是看了之后发现其实也没那么难，于是决定顺手翻译成中文，顺便穿插一点自己的理解。希望能帮到后来的萌新。碎碎念结束，下面正式开始。</p>
<h3 id="你将做什么"><a href="#你将做什么" class="headerlink" title="你将做什么"></a>你将做什么</h3><p>通过本教程，你将会创建一个经典的“Hello, World!”接口，所有浏览器都可以通过URL访问这个接口并得到响应。你可以在URL中设定你的名字，接口就会用更加友好的方式来会响应你。</p>
<h3 id="你需要准备什么"><a href="#你需要准备什么" class="headerlink" title="你需要准备什么"></a>你需要准备什么</h3><ol>
<li><strong>一个你喜欢的IDE</strong></li>
</ol>
<p>比较热门的选择有Intellij IDEA、Spring Tools、Visual Studio Code、Eclipse和很多其他的。</p>
<ol start="2">
<li><strong>一个JDK</strong></li>
</ol>
<p>我们推荐<a target="_blank" rel="noopener" href="https://bell-sw.com/pages/downloads/#/java-17-lts">BellSoft Liberica JDK</a> version 17。</p>
<blockquote>
<p>译者注：IDE方面，相对而言使用IDEA的人更多。我使用的是VSCode。IDEA确实更加智能，甚至过于智能了。我更喜欢在IDE中编辑完毕后敲命令行的感觉，这让我能更好地把握我每一步都做了什么事，不至于被IDE一股脑地包办，稀里糊涂地完成了项目，总觉得这样学习效果不好。JDK方面，我的环境是Oracle的JDK20。</p>
</blockquote>
<h2 id="第一步：新建一个Spring-Boot项目"><a href="#第一步：新建一个Spring-Boot项目" class="headerlink" title="第一步：新建一个Spring Boot项目"></a>第一步：新建一个Spring Boot项目</h2><p>用<a target="_blank" rel="noopener" href="http://start.spring.io/">start.spring.io</a>这个网站来创建一个Web项目。在”Dependencies”里面找到并添加Spring Web这个依赖。选完之后点击”Generate”按钮，浏览器会自动开始下载一个zip文件，将其解压到你的工作目录中。</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_spring_init.png"/></center>

<p>通过这个网站生成的项目会包含Spring Boot，一个不需要很多代码和配置就可以让你的应用运行Spring的框架。Spring Boot是创建Spring项目最快且最热门的途径。</p>
<h2 id="第二步：添加代码"><a href="#第二步：添加代码" class="headerlink" title="第二步：添加代码"></a>第二步：添加代码</h2><p>在你的IDE中打开项目，并且定位到 <code>src/main/java/com/example/demo</code> 文件夹下的 <code>DemoApplication.java</code> 这个文件，并为文件添加以下额外的方法和注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是通过Spring Boot来创建”Hello, World”这个简单的网络服务所需要的全部代码了。</p>
<p>我们刚刚添加的 <code>hello()</code> 方法可以接受一个String型的变量 <code>name</code> ，将其和单词 <code>&quot;Hello&quot;</code> 拼在一起后返回。所以如果你在请求中设置 <code>name</code> 为 <code>&quot;Amy&quot;</code> ，程序的响应就会是 <code>&quot;Hello Amy!&quot;</code>。</p>
<p>注解 <code>@RestController</code> 告诉Spring这段代码描述了一个需要能通过网络访问的端口。</p>
<p>注解 <code>@GetMapping(&quot;/hello&quot;)</code> 告诉Spring要使用上面定义的 <code>hello()</code> 方法来响应被发送到地址 <code>http://localhost:8080/hello</code> 的请求。</p>
<p>最后， 注解 <code>@RequestParam</code> 告诉Spring请求里需要有一个值，也就是上面提到的 <code>name</code> ，但是如果请求里没有这么一个值，那就默认采用单词 <code>&quot;World&quot;</code> 来代替。</p>
<h2 id="第三步：试试看"><a href="#第三步：试试看" class="headerlink" title="第三步：试试看"></a>第三步：试试看</h2><p>让我们来构建并运行这个程序。打开一个命令行（或终端）并且设置工作目录为你的项目存放的目录。我们可以通过以下命令来构建并运行这个应用：</p>
<p><strong>MacOS&#x2F;Linux:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew bootRun</span><br></pre></td></tr></table></figure>

<p><strong>Windows:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\gradlew.bat bootRun</span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：上面应该是默认采用了gradle wrapper作为构建工具了。我使用的是maven wrapper，对应的命令为 .\mvnw spring-boot:run。maven在构建过程中可能需要从远程仓库下载依赖项，国内访问可能会卡，一时不行的话可以等一会儿再试试。</p>
</blockquote>
<p>你应该看到类似的输出：</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_mvnw.png"/></center>

<p>上面的最后两行字告诉我们Spring已经在运行了。Spring Boot内置的Apache Tomcat正在作为这个项目的Web服务器运行，并且正在监听 <code>localhost</code> 的 <code>8080</code> 端口。打开你的浏览器，并在顶部的地址栏输入 <code>http://localhost:8080/hello</code> 。你应该得到这样一个很友好的响应：</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_result.png"/></center>

<h2 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h2><p>如果你在上面的URL的末尾加上 <code>?name=Amy</code> 应该发生什么事呢？</p>
<blockquote>
<p>当然是显示 Hello, Amy! 了。</p>
</blockquote>
<hr>
<h2 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h2><h4 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h4><p>好久没更新博客了。跌跌撞撞结束了春招，拿到了算是相当不错的offer，然后摆了两个月。虽然和当初决心转码时追求WLB的初心有所偏离，但在这个就业形势下已经很不容易了。接下来要狠狠加班了。大概率要转Java岗，所以也在临阵磨枪学起了Spring Boot，不得不说还是Go的Gin简单。主打一个多才多艺。</p>
<h3 id="没事听点歌（温和治疗-明明想了又想又假装没有想）"><a href="#没事听点歌（温和治疗-明明想了又想又假装没有想）" class="headerlink" title="没事听点歌（温和治疗 - 明明想了又想又假装没有想）"></a>没事听点歌（温和治疗 - 明明想了又想又假装没有想）</h3><p>确实还是现场效果更炸一点。</p>
<audio controls>
    <source src="https://cyclohexatriene.github.io/music/明明想了又想又假装没有想.mp3" type="audio/mpeg">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">腾讯（魔方工作室）一面面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 00:07:43 / 修改时间：00:08:08" itemprop="dateCreated datePublished" datetime="2023-03-10T00:07:43+08:00">2023-03-10</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-聊一聊智能指针"><a href="#1-聊一聊智能指针" class="headerlink" title="1. 聊一聊智能指针"></a>1. 聊一聊智能指针</h3><p>智能指针的作用是管理一个指针，避免申请的空间忘记释放导致内存泄漏。智能指针本质上是一个类模板，当超出了类的作用域时，类就会自动调用析构函数回收资源。C++里有四种智能指针：<code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code>,和<code>weak_ptr</code>，其中<code>auto_ptr</code> 在C++11版本已经被废弃。</p>
<ul>
<li><code>auto_ptr</code> （已废弃）</li>
</ul>
<p><code>auto_ptr</code> 采用了所有权模式，后创建的指针会剥夺前面的指针的所有权。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure>

<p>p2会剥夺p1对指针的所有权，此时再访问p1就会出错。所以<code>auto_ptr</code>存在潜在的内存崩溃问题。</p>
<ul>
<li><code>unique_ptr</code> （代替<code>auto_ptr</code>）</li>
</ul>
<p><code>unique_ptr</code>采用独占式拥有概念，保证同一时间内之有一个智能指针可以指向该对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure>

<p>上面的代码无法通过编译，保证在编译期就将问题排查出来。此外，<code>unique_ptr</code>允许被一个临时的右值赋值，例如将上述第二行代码改为<code>p2 = unique_ptr&lt;int&gt;(new int(1))</code>，则可以通过编译，因为这样不会造成悬挂指针的情况。</p>
<ul>
<li><code>shared_ptr</code></li>
</ul>
<p><code>shared_ptr</code>采用共享式拥有概念，多个<code>shared_ptr</code>可以指向相同的对象，并且只有最后一个指向它的<code>shared_ptr</code>被销毁时才会释放它占有的资源。</p>
<ul>
<li><code>weak_ptr</code></li>
</ul>
<p><code>weak_ptr</code>是为了避免两个<code>shared_ptr</code>互相引用，导致其计数永远不会归零、资源永远不会被释放的死锁现象而引入的。它不控制对象的生命周期，不会改变计数器。<code>weak_ptr</code>没有重载<code>*</code>和<code>-&gt;</code>运算符，所以不能直接访问和修改引用的对象（可以通过<code>lock()</code>函数将其转化为<code>shared_ptr</code>然后再访问），但可以访问对象的引用数量等信息，它更像是一个<code>shared_ptr</code>的监控者。</p>
<h3 id="2-能不能自己实现一个shared-ptr？"><a href="#2-能不能自己实现一个shared-ptr？" class="headerlink" title="2. 能不能自己实现一个shared_ptr？"></a>2. 能不能自己实现一个<code>shared_ptr</code>？</h3><p>自己封装一个类模板就行。需要实现构造函数和析构函数、拷贝构造函数和拷贝赋值函数，还有重载一些指针的操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_cnt</span> &#123;</span></span><br><span class="line"><span class="comment">//计数器类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_cnt</span>() :<span class="built_in">cnt</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* ptr;</span><br><span class="line">	shared_cnt* cb;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数和析构函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(T* p = <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ptr = p;</span><br><span class="line">		cb = <span class="keyword">new</span> <span class="built_in">shared_cnt</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">my_shared_ptr</span>() &#123;</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针操作</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr; <span class="comment">// p-&gt;m被解释为(p.operator-&gt;())-&gt;m，所以返回值应该是一个指针。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(<span class="keyword">const</span> my_shared_ptr&amp; other) &#123;</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 赋值函数</span></span><br><span class="line">	my_shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> my_shared_ptr&amp; other) &#123;</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;old ptr has been deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cb-&gt;<span class="built_in">getCnt</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-虚函数是什么原理？"><a href="#3-虚函数是什么原理？" class="headerlink" title="3. 虚函数是什么原理？"></a>3. 虚函数是什么原理？</h3><p>每个包含虚函数的类（或者继承了包含虚函数的基类）都有一个自己的虚函数表，这个表是一个编译时就确定的静态数组。虚函数表包含了指向每个虚函数的函数指针。而编译器会在基类中定义一个隐藏的指针<code>vptr</code>，这是一个指向虚函数表的指针，在类对象创建的时候<code>vptr</code> 会设置成指向类的虚函数表。所以含有虚函数的类会多分配一个指针的大小。如果子类重写了基类的虚函数，就会将虚函数表中的函数指针覆盖为自己重写的函数以供调用。</p>
<p>如以下例子所示，基类<code>Base</code>有<code>function1</code>和<code>function2</code>两个函数，子类<code>D1</code>和<code>D2</code>分别重写了这两个函数。所以在<code>D1</code>的对象的虚函数表中，<code>function1</code>会指向自己重写的新函数，而<code>function2</code>会指向基类的<code>function2</code>，<code>D2</code>同理。</p>
<img src="https://cyclohexatriene.github.io/images/virtual-func.jpg">

<p>还有一个很巧妙的事情。看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D1 d1;</span><br><span class="line">Base *dPtr = &amp;d1;</span><br></pre></td></tr></table></figure>

<p>因为 <code>dPtr</code> 是 <code>Base</code> 类型指针，它只指向 <code>d1</code> 对象的 <code>Base</code> 类型部分(即，指向 <code>d1</code> 对象中的 <code>Base</code> 子对象)，而  <code>vptr</code> 也在 <code>Base</code> 类型部分。所以 <code>dPtr</code> 可以访问 <code>Base</code> 类型部分中的 <code>vptr</code> 。同时，这里注意，  <code>dPtr-&gt;__vptr</code> 指向的是 <code>D1</code> 的虚拟函数表，这是在 <code>d1</code> 初始化时就确定的。所以结果，尽管 <code>dPtr</code> 是 <code>Base</code>  类型指针，但它能够访问 <code>D1</code> 的虚函数表。</p>
<p>所以当调用<code>dPtr-&gt;function1()</code>时，发生了这些事情：</p>
<ol>
<li>程序识别到<code>function1()</code>是一个虚函数。</li>
<li>程序使用 <code>dPtr-&gt;__vptr</code> 获取到了 <code>D1</code> 的虚函数表。</li>
<li>它在 <code>D1</code> 的虚函数表中寻找可以调用的 <code>function1() </code>版本，这里是 <code>D1::function1()</code>。</li>
<li>所以这次调用实际调用的就是<code>D1::function1()</code>。</li>
</ol>
<h3 id="4-含有虚函数的类的size问题？"><a href="#4-含有虚函数的类的size问题？" class="headerlink" title="4. 含有虚函数的类的size问题？"></a>4. 含有虚函数的类的size问题？</h3><ul>
<li>如果类里只有一个虚函数，那这个类有多大？</li>
</ul>
<p>只要有虚函数就会创建一个虚表指针，一个指针是4字节，所以这个类就是4字节。</p>
<ul>
<li>那要是有两个虚函数呢？</li>
</ul>
<p>那也是只有一个虚表指针，还是4字节。</p>
<ul>
<li>扩展：类的内存布局</li>
</ul>
<p>在没有继承的情况下，类的内存布局会根据声明顺序依次排布，且会有对齐现象，默认对齐大小为类内最大的基础类型大小。成员函数存在代码区，不占类的内存。静态变量存在全局存储区，也不占类的内存。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时A对象的<code>short a</code>本来占两个字节，为了与<strong>最大的基础类型</strong><code>int</code>对齐，接下来的2字节将会跳过，然后是<code>int b</code>的4字节，一共是8字节。如果将<code>func1</code>设置成虚函数，则会在类的头部出现一个虚表指针，那么A就是12字节。</p>
<p>虚函数表会单独对齐，例如，将<code>b</code>改为<code>double</code>类型，类内存的布局就是：4字节虚表指针，4字节对齐，2字节<code>short a</code>，6字节对齐，然后是8字节的<code>double b</code>，一共是24字节。</p>
<ul>
<li>一个空类是多大？</li>
</ul>
<p>一个空类理论上来说是0字节，但是编译器会为其加入1字节，这是为了它的每个对象都有独一无二的地址。例如对象a的地址是0x00000000，那对象b的地址就不可能再是0x00000000，起码也是0x00000001，这就意味着对象a占据了1字节的空间。 当另一个类继承了这个空类时，这个空类的内存就变回0字节了。</p>
<h3 id="5-虚函数和纯虚函数的区别？"><a href="#5-虚函数和纯虚函数的区别？" class="headerlink" title="5. 虚函数和纯虚函数的区别？"></a>5. 虚函数和纯虚函数的区别？</h3><p>虚函数由基类定义一个默认的函数，子类在继承时可以重写一个自己专属版本，也可以直接采用基类的默认函数；而纯虚函数则由基类给出声明，子类<strong>必须</strong>自行完成定义。含有纯虚函数的类被称作抽象类，无法直接创建实例，需要被继承后创建子类的实例。</p>
<h3 id="6-你的项目里用到了大量的锁，有什么优化方式吗？"><a href="#6-你的项目里用到了大量的锁，有什么优化方式吗？" class="headerlink" title="6. 你的项目里用到了大量的锁，有什么优化方式吗？"></a>6. 你的项目里用到了大量的锁，有什么优化方式吗？</h3><p>我的回答：我目前是获得一次锁只从队列中获取一个任务，可以设计成获得一次锁就从队列里获取若干个任务一起处理，这样可以均摊锁的成本。</p>
<h3 id="7-有没有可能完全不用锁？"><a href="#7-有没有可能完全不用锁？" class="headerlink" title="7. 有没有可能完全不用锁？"></a>7. 有没有可能完全不用锁？</h3><p>我的回答：可以加一层代理，由一个线程统一对任务队列进行管理，接到任务时主动指定某个线程并将其唤醒处理，不使用锁的机制抢任务处理。</p>
<h3 id="8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"><a href="#8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？" class="headerlink" title="8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"></a>8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？</h3><p>我的回答：不是很了解，可以加密，传输密文，或改用HTTPS。</p>
<h3 id="9-那你知道HTTPS的原理吗？"><a href="#9-那你知道HTTPS的原理吗？" class="headerlink" title="9. 那你知道HTTPS的原理吗？"></a>9. 那你知道HTTPS的原理吗？</h3><p>有点长，回头再来学。</p>
<h3 id="10-你知道内存分配的方式吗？比如malloc-x2F-jemalloc之类的"><a href="#10-你知道内存分配的方式吗？比如malloc-x2F-jemalloc之类的" class="headerlink" title="10. 你知道内存分配的方式吗？比如malloc&#x2F;jemalloc之类的"></a>10. 你知道内存分配的方式吗？比如malloc&#x2F;jemalloc之类的</h3><p>我的回答：只知道malloc，但知道操作系统级别的内存分配方式，面试官让我展开说说，我就说了一些操作系统的内存管理方式，比如说连续静态分配、动态分区、分页式之类的。追问如何减少碎片</p>
<ul>
<li><p><code>malloc(size_t size)</code>：C&#x2F;C++标准库的函数，分配<code>size</code>字节的内存，返回所分配区域的第一个字节的指针，如果内存不够就返回NULL。不会对空间进行初始化。 </p>
</li>
<li><p><code>calloc(size_t num, size_t size)</code>：为一个大小是<code>num</code>的数组分配内存，每个元素的大小是<code>size</code>，返回指向所分配区域的第一个字节的指针。如果内存不够就返回NULL。每个元素会被初始化为0。</p>
</li>
<li><p><code>alloca(size_t size)</code>：在栈上申请内存，不需要free函数释放。很快，适合小的分配。但是可移植性差，不推荐使用。</p>
</li>
<li><p><code>tcmalloc</code>：google的内存分配管理模块</p>
</li>
<li><p><code>jemalloc</code>：BSD的内存分配管理模块</p>
</li>
</ul>
<h3 id="11-HTTP报文由哪些结构组成？消息报头都有哪些字段？"><a href="#11-HTTP报文由哪些结构组成？消息报头都有哪些字段？" class="headerlink" title="11. HTTP报文由哪些结构组成？消息报头都有哪些字段？"></a>11. HTTP报文由哪些结构组成？消息报头都有哪些字段？</h3><p><strong>请求报文：</strong></p>
<ol>
<li><p>请求行（请求方法、URL、HTTP版本）</p>
</li>
<li><p>请求头部（客户端信息、目标Host、需求语言等信息）</p>
</li>
<li><p>空行</p>
</li>
<li><p>请求数据（POST的信息）</p>
</li>
</ol>
<p><strong>响应报文：</strong></p>
<ol>
<li><p>状态行（HTTP版本、状态码）</p>
</li>
<li><p>消息报头（必备Content-Type和Content-Length，还有服务器信息、文件最后更新时间、压缩算法等）</p>
</li>
<li><p>空行</p>
</li>
<li><p>响应正文（HTML代码、图片数据等）</p>
</li>
</ol>
<h3 id="12-HTTP状态码有哪些？"><a href="#12-HTTP状态码有哪些？" class="headerlink" title="12. HTTP状态码有哪些？"></a>12. HTTP状态码有哪些？</h3><ol>
<li><p>信息响应，以1开头。例如<code>100 Continue</code>，POST方法可能会将请求头和请求数据分成两个数据包进行发送，服务器收到请求头时就会先响应一个<code>100 Continue</code>表示请求头没有问题，可以继续发请求数据。</p>
</li>
<li><p>成功响应，以2开头。例如<code>200 OK</code>。</p>
</li>
<li><p>重定向消息，以3开头。例如<code>301 Moved Permanently</code>，表示请求资源的URL已被永久更改，会在响应中给出新的URL。还有<code>307 Temporary Redirect</code>和<code>308 Permanent Redirect</code>等。</p>
</li>
<li><p>客户端错误响应，以4开头，例如<code>400 Bad Request</code>、<code>403 Forbidden</code>、<code>404 Not Found</code></p>
</li>
<li><p>服务端错误响应，以5开头，例如<code>502 Bad Gateway</code>、<code>503 Service Unavailable</code>等。</p>
</li>
</ol>
<h3 id="13-Linux环境下，程序出错，错误信息会记录在什么文件里？"><a href="#13-Linux环境下，程序出错，错误信息会记录在什么文件里？" class="headerlink" title="13. Linux环境下，程序出错，错误信息会记录在什么文件里？"></a>13. Linux环境下，程序出错，错误信息会记录在什么文件里？</h3><p>我答了个errno，面试官指出这是系统调用的错误信息；我说那我不知道了，我只见过stdout的错误信息，比如段错误之类的；面试官追问，那除了段错误还有什么呢，我回忆了一下说不知道了（其实还有算术错误，比如分母为0、无对应操作符、返回值类型有误、未定义变量&#x2F;函数、类型溢出等等）。</p>
<p>会存放在core文件里，可以使用gdb打开core文件（指令为<code>gdb [exec file]] [core file]</code>，例如 <code>gdb ./a.o ./core</code>）。指定core文件进入gdb后，gdb会自动显示如下的错误信息，包括错误的类型、出错的线程、代码所在行以及具体是哪句代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./a.o&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">24     cout &lt;&lt; 1/a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>where</code>和<code>bt</code>指令查看，但不会显示出具体的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) where</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong></p>
<ol>
<li>使用<code>ulimit -c</code>查看core文件的最大大小，如果是0则不会生成core文件。如果指定文件大小，但生成的信息超过此大小，就会被裁剪而生成不完整的core文件，在调试此文件时gdb会提示错误。一般直接设置成<code>ulimit -c unlimited</code>就可以了。</li>
<li>如果要查看具体出错在哪行，使用g++编译时要加上<code>-g</code>获取调试信息，否则只会显示在哪个线程出错。</li>
<li>core文件的生成路径记录在<code>/proc/sys/kernel/core_pattern</code>这个文件里。</li>
</ol>
<h3 id="14-手撕代码"><a href="#14-手撕代码" class="headerlink" title="14. 手撕代码"></a>14. 手撕代码</h3><p>给定一个正整数N，打印出比N大的最小的“非重复数”（相邻数位不同，例如1120是重复数，1210是非重复数）。</p>
<p>测试用例：19901, 9901, 1120, 9</p>
<p><strong>思路：</strong>找到最高位的相邻数位相同的位置，对其进行处理（变得更大,必要时进位），剩下的用010101…填充即可。</p>
<p><strong>问题：</strong>如果使用测试用例219901，在一次进位后会变成22开头的数字，需要第二次进位。试图以循环方式处理，被面试官称为“缝缝补补”，很不优雅。</p>
<p><strong>解决方案：</strong>从右往左遍历，每扫到重复的就进行一次增加处理，直到全部相邻数位都不重复</p>
<p><strong>进阶：</strong>不使用string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sin = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	num++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newNum = num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newSin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125; <span class="keyword">while</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>);</span><br><span class="line">		newNum = num;</span><br><span class="line">			newSin = sin;</span><br><span class="line">		&#125;</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">		sin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; newNum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newSin; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i % <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DLC-1-对象切片"><a href="#DLC-1-对象切片" class="headerlink" title="DLC.1 对象切片"></a>DLC.1 对象切片</h3><p><strong>对象切片：</strong>当一个函数的参数是<strong>按值传递</strong>的，且传递的对象类型是<strong>基类</strong>。当调用该函数时，传入派生类对象时，会自动向上转型，将对象转换成基类对象，并删除派生类中新增的任何成员。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">114</span>, <span class="number">514</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    A a = b;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">114</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的输出是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">addr of a: 010FF778</span><br><span class="line">addr of b: 010FF788</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>A a = b</code>这句代码中发生了对象切片。因为这里创建了一个新的A类对象，自然就创建了新的A类的虚表指针，指向基类的函数。但是注意，<strong>如果传递指针，则不会发生对象切片</strong>，因为没有调用类的构造函数，只是一个指针的复制或拷贝过程，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    A* a = b;</span><br><span class="line">    A* a1 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114</span>);</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">    a1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">addr of a: 00D809E8</span><br><span class="line">addr of b: 00D809E8</span><br><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br></pre></td></tr></table></figure>

<p>只有新创建的a1对象调用了基类的函数。</p>
<h3 id="DLC-2-静态联编和动态联编"><a href="#DLC-2-静态联编和动态联编" class="headerlink" title="DLC.2 静态联编和动态联编"></a>DLC.2 静态联编和动态联编</h3><p><strong>联编：</strong>将源代码中的函数调用解释为执行特定的函数代码块的过程称为函数名联编。意思就是，同一个名称的函数有多种，联编就是把调用和具体的实现进行链接映射的操作。</p>
<p>联编中，C++编译器在编译过程中完成的编译叫做<strong>静态联编</strong>。</p>
<p>但是重载、重写、虚函数使得静态联编变得困难。因为编译器不知道用户将选择哪种类型的对象，执行具体哪一块代码。所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这个过程被称为<strong>动态联编</strong>。</p>
<p><strong>编译器对非虚方法使用静态联编，对虚方法使用动态联编。</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v) :<span class="built_in">a</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;function A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) :<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;function B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114514</span>);</span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="built_in">f</span>(b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is A</span><br><span class="line">this is B</span><br><span class="line">function A</span><br><span class="line">function A</span><br></pre></td></tr></table></figure>

<p>可以看到，编译器对虚函数进行了动态联编，分别调用了基类和子类的函数；而对非虚函数进行了静态联编，总是调用基类的函数。</p>
<h3 id="DLC-3-公有、保护、私有继承"><a href="#DLC-3-公有、保护、私有继承" class="headerlink" title="DLC.3 公有、保护、私有继承"></a>DLC.3 公有、保护、私有继承</h3><p>继承时，我们要选择继承方式，例如：<code>class B : public A</code>就是B以公有继承的方式继承了A。</p>
<p>而这个<code>public</code>修饰的是从类A继承来的对象在B里的新权限。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果类B对其进行<strong>公有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为公有对象。</p>
<p>如果类B对其进行<strong>保护继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为保护对象。</p>
<p>如果类B对其进行<strong>私有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为私有对象；<code>c</code>被继承为私有对象。</p>
<p><strong>规律：</strong>以最严格的权限为准。</p>
<h3 id="DLC-4-类和结构体的区别"><a href="#DLC-4-类和结构体的区别" class="headerlink" title="DLC.4 类和结构体的区别"></a>DLC.4 类和结构体的区别</h3><p>在C的时代，struct不能包含函数。</p>
<p>但是在C++时代，struct不仅可以包含函数，还可以包含虚函数、可以继承和多态、可以使用模板，甚至跟class可以互相继承，几乎和class没有区别。C++保留struct的一大原因（甚至可能是唯一原因）就是为了兼容C。</p>
<p>但是区别还是有的。</p>
<ol>
<li>struct的成员默认是public；class的成员默认是private。</li>
<li>struct默认是公有继承；class默认是私有继承。默认继承方式以子类为准。</li>
<li>struct不能定义模板参数，class可以（就像typename）。</li>
</ol>
<p>还有一个细节共同点：struct和class如果定义了构造函数，就都不能用大括号初始化（<code>A a&#123;5&#125;;</code>），如果没定义构造函数，<strong>且成员变量都是公有的</strong>，就可以使用大括号初始化。</p>
<hr>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>牛客网 C++面经</p>
<p><a href=https://zhuanlan.zhihu.com/p/356879347>C++ | 虚函数表及虚函数执行原理详解</a></p>
<p><a herf=https://zhuanlan.zhihu.com/p/354849447>C++手把手带你实现一个智能指针</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/380147337>浅析C++类的内存布局</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/105714609>C&#x2F;C++内存分配函数差异及高效率内存分配库总结</a></p>
<p><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status>HTTP 响应状态码</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/135454697>GET 和 POST 的区别？</a></p>
<p><a href=https://blog.csdn.net/qq_42570601/article/details/114842320>使用GDB(一)：分析core.xxx文件常用方法</a></p>
<p><a href=https://blog.csdn.net/m0_56104219/article/details/123244825>c++中的对象切片</a></p>
<p><a href=https://www.cnblogs.com/scyq/p/12709629.html>C++ 动态联编和静态联编</a></p>
<p><a href=https://blog.csdn.net/sxtdzj/article/details/81906504>C++公有继承，保护继承，私有继承的区别</a></p>
<p><a href=https://blog.csdn.net/alidada_blog/article/details/83419757>【C++】struct和class的区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/01/18/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/18/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Gin学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-18 15:44:57 / 修改时间：16:04:37" itemprop="dateCreated datePublished" datetime="2023-01-18T15:44:57+08:00">2023-01-18</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Gin是基于Go开发的Web微框架，相当简洁好用。</p>
<h1 id="Download-Gin"><a href="#Download-Gin" class="headerlink" title="Download Gin"></a>Download Gin</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>需要 <code>import &quot;github.com/gin-gonic/gin&quot;</code>。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li><code>gin.Default()</code></li>
</ul>
<p>生成一个gin实例。</p>
<h2 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h2><p>HTTP请求中有<strong>GET，POST，PUT，PATCH，DELETE</strong>和<strong>OPTIONS</strong>等方法，还有一个<strong>Any</strong>可以匹配所有方法。</p>
<ul>
<li><code>GET(path, func)</code></li>
</ul>
<p>声明一个“路由”（即被请求的路径<code>path</code>），当客户端（浏览器）使用HTTP的GET方法向服务器请求位于<code>path</code>的页面时，触发func所定义的函数进行处理。这个func只有一个参数，即<code>gin.Context</code>类型的指针，这个指针指向的地址空间储存了一些对传来的HTTP报文解析后的信息，解析过程是gin封装好的。<code>POST(path, func)</code> 等也同理。</p>
<p>此外，Gin还支持分组路由功能。例如有一组路由均为<code>/a</code>打头，则可以写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := r.Group(<span class="string">&quot;/a&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	v1.GET(<span class="string">&quot;/b&quot;</span>, defaultHandler) <span class="comment">// GET /a/b</span></span><br><span class="line">	v1.GET(<span class="string">&quot;/c&quot;</span>, defaultHandler) <span class="comment">// GET /a/c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>有时请求的URL中会承载一定的信息，这部分信息可以使用<code>Param()</code>或<code>Query()</code>获取。</p>
<ul>
<li><code>Param(string)</code></li>
</ul>
<p>如果要使用<code>Param()</code>方法，则声明的URL中需要包含对应的“占位符”（不清楚学名，笔者自己这么称呼的），用冒号来表示。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;hello, %s&quot;</span>, name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，如果浏览器向服务器请求<code>&quot;/user/dzc&quot;</code>，则服务端会返回字符串<code>&quot;hello, dzc&quot;</code>。</p>
<ul>
<li><code>Query(string)</code></li>
</ul>
<p>如果要使用<code>Query()</code>方法，则实际请求的URL中需要包含问号<code>?</code>，将需要发送到服务端的信息以键值对的形式放在问号后面，键值对之间使用<code>&amp;</code>分隔。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	first := c.Query(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">	last := c.Query(<span class="string">&quot;last&quot;</span>)</span><br><span class="line">	out := <span class="string">&quot;hello, &quot;</span> + first + last</span><br><span class="line">	c.String(http.StatusOK, out)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，如果浏览器向服务器请求<code>&quot;/welcome?first=d&amp;last=zc&quot;</code>，则服务器回返回字符串<code>hello, dzc</code>。</p>
<p>另一些时候，浏览器的数据会以POST方法发送给服务器，这部分数据可以使用<code>PostForm()</code>来解析。</p>
<ul>
<li><code>PostForm(string)</code> &amp; <code>DefaultPostForm(string, string)</code></li>
</ul>
<p>用POST方法提交的表单数据也是以键值对的形式表示的，可以使用<code>PostForm()</code>将其解析出来，而该方法的另一个变种<code>DefaultPostForm()</code>则允许使用者在未解析到所需字段时设置一个默认结果，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	login := c.PostForm(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">	passwd := c.DefaultPostForm(<span class="string">&quot;pass&quot;</span>,<span class="string">&quot;defaultpasswd&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> login == <span class="string">&quot;3200104203&quot;</span> &amp;&amp; passwd == <span class="string">&quot;4203&quot;</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Login successful.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Wrong password.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><p>Gin支持返回多种类型的数据，如字符串、JSON、HTML页面等。</p>
<ul>
<li><code>String(int, string)</code></li>
</ul>
<p><code>String()</code>用于返回一个字符串，第一个参数是返回的HTTP状态码，第二个参数是要返回的字符串内容。例如：<code>c.String(http.StatusOK, &quot;hello world&quot;)</code>。</p>
<ul>
<li><code>JSON(int, gin.H)</code></li>
</ul>
<p><code>JSON()</code>用于返回一个JSON对象，第一个参数是返回的HTTP状态码，第二个参数是要返回的JSON内容。<code>gin.H</code>类型实际上就是<code>map[string]interface&#123;&#125;</code>，其中空接口可以代表任何类型（所有类型均视为实现了一个空接口），所以<code>gin.H</code>类的实例相当于一个JSON对象。</p>
<ul>
<li><code>HTML(int, string, gin.H)</code></li>
</ul>
<p><code>HTML()</code>用于返回一个HTML页面，第一个参数是返回的HYTTP状态码，第二个参数是要返回的页面的路径，第三个参数是需要嵌入到HTML中的数据（如果HTML中出现<code>&#123;&#123;.msg&#125;&#125;</code>，即Gin的模板语法，则会用<code>&quot;this is a message from server.&quot;</code>代替）。在使用这个函数之前，需要用<code>LoadHTMLGlob()</code>或<code>LoadHTMLFiles()</code>将HTML页面文件从硬盘加载进内存中，其中前者可以一次加载整个目录下的所有文件，而后者则单独加载某一个文件。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.LoadHTMLFiles(<span class="string">&quot;root/index.html&quot;</span>) <span class="comment">// 或 r.LoadHTMLGlob(&quot;root/*&quot;)</span></span><br><span class="line">r.GET(<span class="string">&quot;/reg&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;this is a message from server.&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件，顾名思义就是在浏览器和服务器中间的一层东西。而这层东西可以对浏览器发来的请求进行拦截并进行一些预处理，例如权限验证等。此外，中间件还可以在服务器完成处理后、向客户端发送响应前进行一些处理（如添加统一的响应头等）。Gin有内置一些中间件，如默认使用的<code>Logger()</code>和<code>Recovery()</code>。</p>
<ul>
<li>全局使用中间件<code>Use(func)</code></li>
</ul>
<p><code>Use()</code>方法用于全局使用中间件。例如：<code>r.Use(gin.Recovery())</code></p>
<ul>
<li>路由分组使用中间件</li>
</ul>
<p>在创建路由分组时可以添加该路由分组使用的中间件。</p>
<p>例如：<code>user := router.Group(&quot;user&quot;,gin.Recovery())</code> 。</p>
<ul>
<li>单个路由使用中间件</li>
</ul>
<p>在创建单个路由时也可以添加该路由使用的中间件。</p>
<p>例如：<code>r.GET(&quot;/&quot;,gin.Recovery(),DefaultHandler)</code> 。</p>
<ul>
<li>自定义中间件</li>
</ul>
<p>Gin规范了自定义中间件的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyMiddleware</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义中间件时，如果需要与服务端进行<strong>数据传递</strong>的话，可以使用<code>Set()</code>和<code>Get()</code>方法。</p>
<ul>
<li><code>Set(string, interface&#123;&#125;)</code></li>
</ul>
<p>使用<code>Set()</code>时，相当于为<code>gin.Context</code>设置了一个键值对。其中键必须是<code>string</code>类型的，而值可以是任意类型的。</p>
<ul>
<li><code>Get(string)</code></li>
</ul>
<p>使用<code>Get()</code>可以将之前<code>Set()</code>的值读取出来，其返回两个值，第一个是键对应的值，第二个是该键是否存在，用布尔类型表示。</p>
<p><code>Next()</code>方法可以划分中间件的前置和后置功能。<code>Next()</code>调用前的代码将在请求到达服务端之前进行，而<code>Next()</code>调用后的代码则会在服务端处理完毕后、正式向客户端发送响应前运行。</p>
<p><code>Abort()</code>方法可以拦截请求&#x2F;响应。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyMiddlewareForAuth := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	login := c.PostForm(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">	passwd := c.PostForm(<span class="string">&quot;pass&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> login == <span class="string">&quot;3200104203&quot;</span> &amp;&amp; passwd == <span class="string">&quot;4203&quot;</span> &#123;</span><br><span class="line">		c.Set(<span class="string">&quot;Authres&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.Set(<span class="string">&quot;Authres&quot;</span>, <span class="number">0</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Wrong password.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/register&quot;</span>, MyMiddlewareForAuth, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> val, exists := c.Get(<span class="string">&quot;Authres&quot;</span>); exists &amp;&amp; val == <span class="number">1</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Login successful.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;hello?\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/quick-go-gin.html">https://geektutu.com/post/quick-go-gin.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151818857">https://zhuanlan.zhihu.com/p/151818857</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1585029">https://cloud.tencent.com/developer/article/1585029</a></p>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（Billie-Eilish-bad-guy）"><a href="#没事听点歌（Billie-Eilish-bad-guy）" class="headerlink" title="没事听点歌（Billie Eilish - bad guy）"></a>没事听点歌（Billie Eilish - bad guy）</h2><audio controls>
    <source src = "https://cyclohexatriene.github.io/music/bad guy.mp3">
</audio>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/12/14/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">离线查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-14 16:21:36 / 修改时间：17:53:08" itemprop="dateCreated datePublished" datetime="2022-12-14T16:21:36+08:00">2022-12-14</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久不见，刚好一个月没更新了。一个月里还发生了蛮多事的，单一个防疫政策就已经大变天了。希望能看到这句话的朋友们都能保护好自己，能晚不早，能阴不阳。</p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>在线</strong> 和 <strong>离线</strong> 可以简单地理解为<strong>对于所有的操作是否需要读入完毕</strong>。</p>
<p>在线算法的要求是，不用先知道所有的操作（如查询、修改等），一边读入一边执行，所有操作之间的独立性比较高。</p>
<p>而离线算法则相反，要求必须先知道所有的操作，再执行操作。这样的话，我们就有机会合理安排操作顺序，以更高的效率完成所有操作。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-1697-检查边长度限制的路径是否存在"><a href="#LeetCode-1697-检查边长度限制的路径是否存在" class="headerlink" title="LeetCode 1697. 检查边长度限制的路径是否存在"></a>LeetCode 1697. 检查边长度限制的路径是否存在</h2><p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [ui, vi, disi]</code> 表示点 <code>ui</code> 和点 <code>vi</code> 之间有一条长度为 <code>disi</code> 的边。请注意，两个点之间可能有 <strong>超过一条边</strong> 。</p>
<p>给你一个查询数组 <code>queries</code> ，其中 <code>queries[j] = [pj, qj, limitj]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>pj</code> 到 <code>qj</code> 的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limitj</code> 。</p>
<p>请你返回一个 <strong>布尔数组</strong> <code>answer</code> ，其中 <code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第 <code>j</code> 个值为 <code>true</code> ，否则为 <code>false</code> 。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><img src="https://cyclohexatriene.github.io/images/1697_1.png"/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edgeList = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">16</span>]], queries = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：上图为给定的输入数据。注意到 <span class="number">0</span> 和 <span class="number">1</span> 之间有两条重边，分别为 <span class="number">2</span> 和 <span class="number">16</span> 。</span><br><span class="line">对于第一个查询，<span class="number">0</span> 和 <span class="number">1</span> 之间没有小于 <span class="number">2</span> 的边，所以我们返回 <span class="literal">false</span> 。</span><br><span class="line">对于第二个查询，有一条路径（<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span>）两条边都小于 <span class="number">5</span> ，所以这个查询我们返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><img src="https://cyclohexatriene.github.io/images/1697_2.png"/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edgeList = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">13</span>]], queries = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">14</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：上图为给定数据。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的第一反应是在线查询的思路，就是把每个 <code>query</code> 都当成独立的，然后再写一个函数判断是否可行，而这个函数的算法可能会采用BFS。后来觉得容易TLE，瞄了眼题解发现要用并查集。然后我就闷头写了个并查集，查询时，将边长度小于当前 <code>query</code> 限制距离的边的两个端点 <code>union</code> 起来，发现还是TLE。（有关并查集的内容可以查阅 <a href = "https://cyclohexatriene.github.io/2022/07/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/">这篇文章</a> 。）</p>
<p>然后仔细研究了题解，发现了离线查询这东西。因为题目的查询操作都是给定的，所以我们可以根据每个 <code>query</code>的距离限制对 <code>queries</code> 数组进行升序排序，同时也根据边的长度对 <code>edgeList</code> 进行升序排序，再按照新的<code>queries</code> 顺序进行操作。这样，限制距离更小的 <code>query</code> 操作起来就是限制距离更大的 <code>query</code> 的子集，跟在线查询比都不知道省到哪里去了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> root = <span class="built_in">find</span>(vec[a]);</span><br><span class="line">            vec[a] = root;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        vec[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">distanceLimitedPathsExist</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vec = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">iota</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(queries.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(edgeList.<span class="built_in">begin</span>(), edgeList.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt;&amp; e1, vector&lt;<span class="keyword">int</span>&gt;&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">2</span>] &lt; e2[<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">seq</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(seq.<span class="built_in">begin</span>(), seq.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(seq.<span class="built_in">begin</span>(), seq.<span class="built_in">end</span>(), [&amp;queries](<span class="keyword">int</span> i1, <span class="keyword">int</span> i2) &#123;</span><br><span class="line">            <span class="keyword">return</span> queries[i1][<span class="number">2</span>] &lt; queries[i2][<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : seq) &#123;</span><br><span class="line">            <span class="keyword">while</span> (idx &lt; edgeList.<span class="built_in">size</span>() &amp;&amp; edgeList[idx][<span class="number">2</span>] &lt; queries[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(edgeList[idx][<span class="number">0</span>], edgeList[idx][<span class="number">1</span>]);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = (<span class="built_in">find</span>(queries[i][<span class="number">0</span>]) == <span class="built_in">find</span>(queries[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceLimitedPathsExist</span><span class="params">(n <span class="keyword">int</span>, edgeList [][]<span class="keyword">int</span>, queries [][]<span class="keyword">int</span>)</span> []<span class="title">bool</span></span> &#123;</span><br><span class="line">    vec := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> vec &#123;</span><br><span class="line">        vec[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> find <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    find = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> vec[a] != a &#123;</span><br><span class="line">            vec[a] = find(vec[a])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[a]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    union := <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        vec[find(a)] = find(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        queries[i] = <span class="built_in">append</span>(queries[i], i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Slice(edgeList,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeList[i][<span class="number">2</span>] &lt; edgeList[j][<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    sort.Slice(queries,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queries[i][<span class="number">2</span>] &lt; queries[j][<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">bool</span>,<span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">var</span> idx <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(edgeList) &amp;&amp; edgeList[idx][<span class="number">2</span>] &lt; query[<span class="number">2</span>] &#123;</span><br><span class="line">            union(edgeList[idx][<span class="number">0</span>],edgeList[idx][<span class="number">1</span>])</span><br><span class="line">            idx++</span><br><span class="line">        &#125; </span><br><span class="line">        res[query[<span class="number">3</span>]] = find(query[<span class="number">0</span>]) == find(query[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="入坑Golang"><a href="#入坑Golang" class="headerlink" title="入坑Golang"></a>入坑Golang</h2><p>投实习的时候发现好多后端都要求用Go开发，于是决定入坑。语法上过了一遍菜鸟教程，然后力扣上题也刷起来了，中等以下的题都是直接用Go写，今天的Hard用C++写了一遍之后再用Go写了一遍。Go的语法就像是C&#x2F;C++和Python的融合怪，取了二者之精华，还增加了一些C&#x2F;C++并没有但是很实用很酷炫的特性（比如for … range语法可以同时迭代下标和值），我很中意。但也有很多有些别扭的地方，比如不支持<code>set</code> ，只有 <code>map</code> ，虽然本质上差不多，也可以用 <code>map</code> 实现 <code>set</code> 的功能，但是用起来就是很麻烦。还没内置 <code>queue</code> 、 <code>stack</code> 之类的数据结构，甚至连 <code>min</code> 、 <code>max</code> 这种简单而又常用的函数都需要自己手搓。<del>STL真是绝绝子好用到跺jiojio。</del></p>
<h2 id="没事听点歌（Coldplay-Viva-La-Vida）"><a href="#没事听点歌（Coldplay-Viva-La-Vida）" class="headerlink" title="没事听点歌（Coldplay - Viva La Vida）"></a>没事听点歌（Coldplay - Viva La Vida）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/Viva La Vida.mp3">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/11/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">折半搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-14 22:20:28 / 修改时间：22:42:07" itemprop="dateCreated datePublished" datetime="2022-11-14T22:20:28+08:00">2022-11-14</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>折半搜索（meet-in-the-middle），虽然听起来有点像二分查找，但是其实是两种不同的算法。一般针对数组元素组合的暴力搜索，复杂度会来到 <code>O(2^n)</code>，稍微有点数据量就容易TLE。而折半搜索则是一种取巧的方式，一次只爆搜一半的数据，爆搜两次，然后将两次爆搜的结果组合起来，就可以提升很多效率。不过复杂度依然是指数级别的。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-805-数组的均值分割"><a href="#LeetCode-805-数组的均值分割" class="headerlink" title="LeetCode 805. 数组的均值分割"></a>LeetCode 805. 数组的均值分割</h2><p>给定你一个整数数组 <code>nums</code></p>
<p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p>
<p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code> 。</p>
<p><strong>注意：</strong>对于数组 <code>arr</code> ,  <code>average(arr)</code> 是 <code>arr</code> 的所有元素的和除以 <code>arr</code> 长度。</p>
<p><strong>提示：</strong>1 &lt;&#x3D; nums.length &lt;&#x3D; 30</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 我们可以将数组分割为 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>] 和 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 他们的平均值都是<span class="number">4.5</span>。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>分割后的两个数组的平均数相同，那么把它们和回去，平均数肯定不变，所以两个数组的平均数等于原数组的平均数。所以我们只需要判断原数组是否存在一个<strong>平均数和原数组的平均数相等</strong>的非空子数组就行了。</p>
<p>本题数组最长长度会有30，如果直接二进制暴力枚举的话，需要枚举 <code>2^30</code> 次，指定会TLE。所以就可以使用折半搜索，先搜索前半部分，然后把搜索结果存进哈希表里，然后再搜剩下一半。在搜剩下一半时，每枚举到一种组合，就再枚举它和前半部分组合后的组合的长度和这个长度对应的理论元素总和，然后去哈希表中查找这个理论总和是否真实存在，如果存在就说明我们找到了可行解，返回 <code>true</code> 即可。这样我们最多只需要枚举两个 <code>2^15</code> 就行，数量级一下子就下来了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitArraySameAverage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; map;<span class="comment">/* cnt,sum */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">int</span> tsum = <span class="number">0</span>, tcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    tsum += nums[idx];</span><br><span class="line">                    tcnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map[tsum].<span class="built_in">insert</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = n - m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; r); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">int</span> tsum = <span class="number">0</span>, tcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    tsum += nums[m + idx];</span><br><span class="line">                    tcnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>,tcnt); j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j * sum % n != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> t = j * sum / n;</span><br><span class="line">                <span class="keyword">if</span> (map[t - tsum].<span class="built_in">count</span>(j - tcnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（金玟岐-岁月神偷）"><a href="#没事听点歌（金玟岐-岁月神偷）" class="headerlink" title="没事听点歌（金玟岐 - 岁月神偷）"></a>没事听点歌（金玟岐 - 岁月神偷）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/岁月神偷.mp3">
</audio>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/11/13/WebServer%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/13/WebServer%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">WebServer记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-13 14:37:00 / 修改时间：16:05:05" itemprop="dateCreated datePublished" datetime="2022-11-13T14:37:00+08:00">2022-11-13</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久没来更新了，从上次更新到现在忙了很多事情，而且忙了半天也不知道自己忙了些啥，很丧。做的为数不多的比较扎实的事情就是仿照着GitHub上的<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">开源项目</a>写了一个WebServer，目前已经完成了一个可以传输静态页面的Demo，还需要优化以及添加一些别的功能。先记录一下，免得以后忘了。</p>
<hr>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><p>程序采用的是“半同步半反应堆式”的线程池，也就是：</p>
<ul>
<li><p>主线程负责监听文件描述符上发生的事件，并针对事件进行IO。</p>
</li>
<li><p>子线程负责处理逻辑，解析收到的HTTP报文，准备好要发送的数据，并通知主线程可以进行IO了。</p>
</li>
</ul>
<p>具体实现时，程序分为了若干个模块：线程同步模块、日志模块、MySQL连接池模块、HTTP处理模块、mmap模块、线程池模块、epoll监听模块。</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>是整个项目最简单的一部分，也是上手完成的第一个部分，就是把Linux底层提供的一些线程同步机制进行了封装，使用的时候会更加方便一些。把<code>init()</code>和<code>destroy()</code>分别写进了构造函数和析构函数，随取随用，让代码更加简洁，应该也属于所谓的<code>RAII</code>机制。</p>
<blockquote>
<p>RAII机制：资源获取就是初始化（Resource Acquisition Is Initialization），这是一种管理资源的方式，C++保证任何情况下，已构造的对象最终都会销毁，即它的析构函数一定会被调用。所以只要把资源的获取和释放分别封装进一个类的构造函数和析构函数，就可以保证资源不会发生“泄露”。</p>
</blockquote>
<h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>();</span><br><span class="line">    ~<span class="built_in">locker</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span>* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>();</span><br><span class="line">    ~<span class="built_in">cond</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>();</span><br><span class="line">    <span class="built_in">sem</span>(<span class="keyword">int</span> num);</span><br><span class="line">    ~<span class="built_in">sem</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>条件变量与信号量的区别：个人理解中，信号量sem本质上是一个计数的功能，post就是让信号量加一，wait就是让信号量减一，post和wait调用先后问题不大；而条件变量cond则必须先wait再signal或broadcast，否则就会发生丢失信号的现象，特定情况下甚至会造成死锁。另外，信号量可以在进程之间共享，而条件变量只能在进程内部、线程之间共享。</p>
</blockquote>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志系统实现了同步写日志和异步写日志两种模式。同步写日志就是调用了写日志函数之后就等着写完了才退出函数，异步写日志则是在日志系统中维护了一个“生产者-消费者”模型，写日志的函数只负责生产任务，而真正的写入工作则由异步线程完成。为了实现这个“生产者-消费者”模型，我编写了一个阻塞队列，就是把STL中带有的队列模板进行进一步封装，让它的每一个操作都是线程安全的。这样生产者只管push，消费者只管pop就行了。</p>
<p>回到日志系统本身。日志类是在单例模式下编写的。所谓的单例模式，就是把这个类的构造函数和析构函数都私有化，只有类自己能调用，程序的其它部分不能创建新的对象；然后在这个类里<strong>静态地</strong>内置一个自己，保证整个程序只有这一个对象，并可通过类的<strong>静态</strong>方法来获取这个唯一对象。</p>
<h2 id="代码摘录："><a href="#代码摘录：" class="headerlink" title="代码摘录："></a>代码摘录：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    ~<span class="built_in">Log</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL连接池"><a href="#MySQL连接池" class="headerlink" title="MySQL连接池"></a>MySQL连接池</h1><p>由于建立和释放MySQL连接是非常消耗资源的，所以用到了临时建立连接太低效了，我们可以维护一个连接池，在初始化时建立一些连接，程序在需要时就可以直接从池里获得一个连接，用完还回来就行。同样采用单例的编写模式。连接池模块有两个类，一个是连接池本体，一个是<code>RAII</code>的接口，接口初始化时从池里获取连接，析构时自动归还。</p>
<h2 id="连接池本体声明："><a href="#连接池本体声明：" class="headerlink" title="连接池本体声明："></a>连接池本体声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connection_pool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">connection_pool</span>();</span><br><span class="line">    ~<span class="built_in">connection_pool</span>();</span><br><span class="line">    string user;</span><br><span class="line">    string passwd;</span><br><span class="line">    string DatabaseName;</span><br><span class="line">    <span class="keyword">bool</span> close_log; <span class="comment">/* If true, the connection pool won&#x27;t write logs. */</span></span><br><span class="line">    <span class="keyword">int</span> max_conn;</span><br><span class="line">    locker m_locker;</span><br><span class="line">    list&lt;MYSQL*&gt; connList;</span><br><span class="line">    sem m_sem; <span class="comment">/* sem &gt; 0 means there is free connections. */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> connection_pool* <span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> connection_pool instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string user, string password, string name, <span class="keyword">int</span> maxconn, <span class="keyword">bool</span> close_log = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MYSQL* <span class="title">getConnection</span><span class="params">()</span></span>; <span class="comment">/* Get a free connection from pool. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">releaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">/* Return a connection into the pool. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyPool</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="HTTP处理"><a href="#HTTP处理" class="headerlink" title="HTTP处理"></a>HTTP处理</h1><p>这个模块暂时只实现了传输静态页面，图片、文件的传输还有待研究。类里有一个<code>process()</code>函数，用于处理输入、获得待写输出。<code>process()</code>函数由线程池异步调用，处理好再通知主线程进行一个数据的写。</p>
<h2 id="声明：-1"><a href="#声明：-1" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">/*private*/</span></span><br><span class="line">    <span class="keyword">char</span> state_line[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> headers[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http</span>();</span><br><span class="line">    <span class="built_in">http</span>(<span class="keyword">char</span> pack[], <span class="keyword">int</span> fd);</span><br><span class="line">    ~<span class="built_in">http</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> clntfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> package[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span> <span class="comment">/* iov[0]: state_line; iov[1]: headers; iov[2]: resource to be got */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>iovec</code>，就是分布式IO，可以把需要IO的部分（用起始地址和偏移量表示）存进一个向量里，然后调用<code>readv()</code>或<code>writev()</code>一次性读写多个缓冲区，相当优雅。</p>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h1><p>对底层的mmap API进行了封装。mmap还没用明白，所以暂时还没用进程序里，不过理论上可以大幅度提高程序的IO性能。</p>
<blockquote>
<p>mmap是一种内存映射文件的方式。普通的文件读写，需要先open()，把文件在读取进操作系统内核的内存里，然后再read()和write()，将内核的内存拷贝进用户态的内存里，造成了效率的浪费；而使用mmap，则可以让内核和用户共享一块内存，省去了第二步的拷贝，更加高效。</p>
</blockquote>
<h2 id="声明：-2"><a href="#声明：-2" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mmap_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">void</span> *start; <span class="comment">/* The start of mmap. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mmap_file</span>();</span><br><span class="line">    <span class="built_in">mmap_file</span>(string path);</span><br><span class="line">    ~<span class="built_in">mmap_file</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openFile</span><span class="params">(string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">getStart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输入一个文件路径，获取这个文件mmap后的起始内存和偏移量。不过好像iovec不能直接用，还没来得及研究和调试。</p>
<h1 id="线程池模块"><a href="#线程池模块" class="headerlink" title="线程池模块"></a>线程池模块</h1><p>复用了日志模块的阻塞队列，将已经完成了读操作的http对象加入到工作队列中，由线程池维护的若干个线程竞争获取任务，然后在子线程中异步地完成处理，并注册对应文件描述符上的写事件，通知主线程进行一个写。同样采用单例模式编写。</p>
<h2 id="声明：-3"><a href="#声明：-3" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>();</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>; <span class="comment">/* Call process() in an infinite loop. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_t</span>* m_threads;</span><br><span class="line">    block_queue&lt;http*&gt; workq;</span><br><span class="line">    <span class="keyword">int</span> m_thread_number;</span><br><span class="line">    sem m_sem;</span><br><span class="line">    locker m_locker;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(http* request)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> threadpool* <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> threadpool instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="EPOLL-监听"><a href="#EPOLL-监听" class="headerlink" title="EPOLL 监听"></a>EPOLL 监听</h1><p>EPOLL是一种IO多路复用的模型，类似的模型还有SELECT和POLL，但他俩都不如EPOLL好使。在我写的项目里就以单例模式维护了一个EPOLL的监听池，封装了一些API，方便程序直接调用。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>简单地理解就是在一个线程同时监听一大堆文件描述符是否有可写事件和可读事件发生，这样程序可以同时处理来自多个事件流中的事件。</p>
<h2 id="SELECT、POLL和EPOLL的区别"><a href="#SELECT、POLL和EPOLL的区别" class="headerlink" title="SELECT、POLL和EPOLL的区别"></a>SELECT、POLL和EPOLL的区别</h2><p>最早被写出来的IO多路复用模型是SELECT，实现思路也非常耿直：就是维护一个数组，调用<code>wait()</code>的时候就去遍历一遍这个数组，看看每个文件描述符是否有事件发生，如果有的话就拎出来告诉调用者。因为用的是数组，所以监听的文件描述符数量有上限，大概是1024个。</p>
<p>而POLL所作出的改进是用链表代替了普通的数组，突破了1024个的上限。但由于还是采用遍历的方式来判断是否有事件发生，依然是线性的复杂度。</p>
<p>然后EPOLL就闪亮登场了。EPOLL底层维护了一棵红黑树和一个链表，红黑树用于保存文件描述符，链表用于保存已经发生了事件的文件描述符。与前两代模型不同，EPOLL不是主动地去遍历，而是给每个文件描述符设置一个“回调函数”，当有事件发生时就自动调用，把文件描述符存进链表中，这样就可以不用遍历了，调用<code>wait()</code>时只需要返回那个链表就行，时间复杂度是常量级的。</p>
<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="网抑云（五月天、孙燕姿-温柔-MaydayBlue20th）"><a href="#网抑云（五月天、孙燕姿-温柔-MaydayBlue20th）" class="headerlink" title="网抑云（五月天、孙燕姿 - 温柔 #MaydayBlue20th）"></a>网抑云（五月天、孙燕姿 - 温柔 #MaydayBlue20th）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/温柔.mp3">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/10/23/%E6%AF%8F%E6%97%A5Hard-Day-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/23/%E6%AF%8F%E6%97%A5Hard-Day-12/" class="post-title-link" itemprop="url">每日Hard - Day 12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-23 14:19:24 / 修改时间：14:25:55" itemprop="dateCreated datePublished" datetime="2022-10-23T14:19:24+08:00">2022-10-23</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年10月23日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>不完全是就是完全不是</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>随机化</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#LeetCode-381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复</h2><p><code>RandomizedCollection</code> 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。</p>
<p>实现 <code>RandomizedCollection</code> 类:</p>
<ul>
<li><code>RandomizedCollection()</code>初始化空的 <code>RandomizedCollection</code> 对象。</li>
<li><code>bool insert(int val)</code> 将一个 <code>val</code> 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>bool remove(int val)</code> 如果存在，从集合中移除一个 <code>val</code> 项。如果该项存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。注意，如果 <code>val</code> 在集合中出现多次，我们只删除其中一个。</li>
<li><code>int getRandom()</code> 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 <strong>线性相关</strong> 。</li>
</ul>
<p>您必须实现类的函数，使每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>
<p><strong>注意：</strong>生成测试用例时，只有在 <code>RandomizedCollection</code> 中 <strong>至少有一项</strong> 时，才会调用 <code>getRandom</code> 。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;RandomizedCollection&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;getRandom&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;getRandom&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">2</span>], [], [<span class="number">1</span>], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedCollection collection = <span class="keyword">new</span> <span class="built_in">RandomizedCollection</span>();<span class="comment">// 初始化一个空的集合。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">1</span>);<span class="comment">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">1</span>);<span class="comment">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">2</span>);<span class="comment">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span></span><br><span class="line">collection.<span class="built_in">getRandom</span>();<span class="comment">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span></span><br><span class="line">collection.<span class="built_in">remove</span>(<span class="number">1</span>);<span class="comment">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span></span><br><span class="line">collection.<span class="built_in">getRandom</span>();<span class="comment">// getRandom 应有相同概率返回 1 和 2 。</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>是我最喜欢的数据结构运用题。这里有一个小技巧，就是一般<code>vector</code>是不允许<code>O(1)</code>时间复杂度的随机删除的，但是本题中我们不在乎用到的<code>vector</code>里元素的顺序是怎么样的，那么我们就可以把需要删除的元素和末位元素进行一个位置互换，然后我们就能直接在<code>O(1)</code>时间复杂度下<code>pop_back()</code>了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; map;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedCollection</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        map[val].<span class="built_in">insert</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        nums.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (map[val].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[val].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> torm = *map[val].<span class="built_in">begin</span>();</span><br><span class="line">            map[val].<span class="built_in">erase</span>(torm);</span><br><span class="line">            map[nums.<span class="built_in">back</span>()].<span class="built_in">insert</span>(torm);</span><br><span class="line">            map[nums.<span class="built_in">back</span>()].<span class="built_in">erase</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(nums[torm], nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            nums.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rndidx = <span class="built_in">rand</span>() % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[rndidx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="环己三烯"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">环己三烯</p>
  <div class="site-description" itemprop="description">万里长征人未还</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">环己三烯</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'UsSNtA9GJ5h8tGViWaV97qbO-9Nh9j0Va',
      appKey     : 'J83xwqE3YCKgWOy0dIBrad1s',
      placeholder: "莫西莫西？",
      avatar     : 'hide',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://ussnta9g.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
