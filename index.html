<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cyclohexatriene.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="万里长征人未还">
<meta property="og:type" content="website">
<meta property="og:title" content="环己三烯的冬眠舱">
<meta property="og:url" content="http://cyclohexatriene.github.io/index.html">
<meta property="og:site_name" content="环己三烯的冬眠舱">
<meta property="og:description" content="万里长征人未还">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="环己三烯">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cyclohexatriene.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>环己三烯的冬眠舱</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">环己三烯的冬眠舱</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天天网抑云，偶尔读点书。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-comment-board">

    <a href="/comment-board" rel="section">留言板</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2024/03/25/WSL2-CLion-%E7%BC%96%E8%AF%91%E5%B9%B6%E8%B0%83%E8%AF%95JDK12%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/WSL2-CLion-%E7%BC%96%E8%AF%91%E5%B9%B6%E8%B0%83%E8%AF%95JDK12%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">WSL2 + CLion 编译并调试JDK12源码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-25 13:39:25 / 修改时间：15:37:05" itemprop="dateCreated datePublished" datetime="2024-03-25T13:39:25+08:00">2024-03-25</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近打算开始读《深入理解Java虚拟机》，作者在第一章推荐读者自己编译一份JDK，并使用CLion来阅读和调试源码。由于笔者没有原生的Linux或MacOS环境，只能使用WSL2来平替。在配置过程中踩了一些坑，遂记录一下，没准以后会有人需要。</p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>源码的仓库在<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk/jdk12">https://hg.openjdk.java.net/jdk/jdk12</a> ，点击左边的browse就是源码的文件目录了。本来想直接在WSL里使用wget来下载.tar.gz文件，发现下载不动，于是选择使用Windows的浏览器直接下载.tar.gz，再从文件系统里找到WSL的目录复制进去。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/1.png"></p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/2.png"></p>
<p>然后从WSL里打开对应目录就能找到源码文件，虽然多了一个不知道有什么用的Identifier（猜测跟Windows的文件系统有关），但是并不影响源码的解压。使用tar指令解压压缩包即可获得源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf jdk12-06222165c35f.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://cyclohexatriene.github.io/images/JDK/3.png"></p>
<h3 id="构建编译环境"><a href="#构建编译环境" class="headerlink" title="构建编译环境"></a>构建编译环境</h3><p>不得不说Linux下配环境确实比Windows方便不少。</p>
<p>在开始之前建议先更新一下软件源：<code>sudo apt-get update</code></p>
<h4 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<h4 id="安装一些依赖库"><a href="#安装一些依赖库" class="headerlink" title="安装一些依赖库"></a>安装一些依赖库</h4><p><img src="https://cyclohexatriene.github.io/images/JDK/4.jpg"></p>
<p>这个表是书的作者提供的，实际操作的时候发现我的环境还缺了一个ZIPEXE（提示<code>Could not find required tool for ZIPEXE</code>），安装后就好了：<code>sudo apt-get install zip</code></p>
<h4 id="安装Bootstrap-JDK"><a href="#安装Bootstrap-JDK" class="headerlink" title="安装Bootstrap JDK"></a>安装Bootstrap JDK</h4><blockquote>
<p>编译大版本号为N的JDK时需要用到另一个大版本号至少为N-1的已经编译好的JDK。因为OpenJDK只有部分代码使用C&#x2F;C++编写，更多的是使用Java编写的，所以需要另一个编译期可用的JDK来编译这部分代码，官方称这个JDK为“Bootstrap JDK”</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<h3 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h3><p>源码目录中有一个叫<code>configure</code>的bash文件，提供检查依赖项是否齐全和设置参数等功能。作者给出的配置指令是<code>bash configure --enable-debug --with-jvm-variants=server</code>，配置完毕后使用<code>make images</code>进行编译。但是实际上我遇到了两个问题。</p>
<h4 id="没有jre目录"><a href="#没有jre目录" class="headerlink" title="没有jre目录"></a>没有jre目录</h4><p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误的路径元素 &quot;/usr/lib/jvm/java-17-openjdk-amd64/jre/lib&quot;: 没有这种文件或目录</span><br></pre></td></tr></table></figure>

<p>我顺着这个目录找下去，发现我只有<code>/usr/lib/jvm/java-17-openjdk-amd64</code>目录，因为从JDK11开始jre已经不是默认安装了。我们可以手动生成一个（需要切换到需要生成jre的JDK的目录）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/jlink --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<p>这里需要调用的应该是上面提到的Bootstrap JDK，但是我环境变量之前配过JDK17，所以这里就调用了JDK17，而不是新下载的JDK11。</p>
<h4 id="调用strncpy产生的奇怪问题"><a href="#调用strncpy产生的奇怪问题" class="headerlink" title="调用strncpy产生的奇怪问题"></a>调用strncpy产生的奇怪问题</h4><p>报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== Output from failing command(s) repeated here ===</span><br><span class="line">* For target hotspot_variant-server_libjvm_objs_arguments.o:</span><br><span class="line">In file included from /usr/include/string.h:495,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/globalDefinitions_gcc.hpp:35,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/globalDefinitions.hpp:32,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/utilities/align.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/runtime/globals.hpp:29,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/memory/allocation.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/classfile/classLoaderData.hpp:28,</span><br><span class="line">                 from /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/precompiled/precompiled.hpp:34:</span><br><span class="line">In function ‘char* strncpy(char*, const char*, size_t)’,</span><br><span class="line">    inlined from ‘static jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs*, bool*, JVMFlag::Flags)’ at /home/dzc/JVM/jdk12-06222165c35f/src/hotspot/share/runtime/arguments.cpp:2472:29:</span><br><span class="line">/usr/include/x86_64-linux-gnu/bits/string_fortified.h:106:34: error: ‘char* __builtin_strncpy(char*, const char*, long unsigned int)’ output truncated before terminating nul copying as many bytes from a string as its length [-Werror=stringop-truncation]</span><br><span class="line">  106 |   return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));</span><br><span class="line">   ... (rest of output omitted)</span><br><span class="line"></span><br><span class="line">* All command lines available in /home/dzc/JVM/jdk12-06222165c35f/build/linux-x86_64-server-fastdebug/make-support/failure-logs.</span><br><span class="line">=== End of repeated output ===</span><br></pre></td></tr></table></figure>

<p>说实话没怎么看懂，似乎和什么字符串被截断有关，在网上查了很久都没找到有类似情况的。然后发现官方有在源码目录里附上docs，于是不抱希望地点开查看，在<code>building.html</code>的<code>Troubleshooting</code>里找到了这样一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hint: If caused by a warning, try configure --disable-warnings-as-errors</span><br></pre></td></tr></table></figure>

<p>又想到报错信息里有这么一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc1plus: all warnings being treated as errors</span><br></pre></td></tr></table></figure>

<p>于是清除原来的配置之后重新配置，添加不把warnings视作errors的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make dist-clean</span><br><span class="line">bash configure --enable-debug --with-jvm-variants=server --disable-warnings-as-errors</span><br></pre></td></tr></table></figure>

<p>之后再<code>make images</code>就编译成功了。进入<code>build/配置名称/jdk/bin</code>目录下执行<code>./java -version</code>可以看到版本信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version &quot;12-internal&quot; 2019-03-19</span><br><span class="line">OpenJDK Runtime Environment (fastdebug build 12-internal+0-adhoc.dzc.jdk12-06222165c35f)</span><br><span class="line">OpenJDK 64-Bit Server VM (fastdebug build 12-internal+0-adhoc.dzc.jdk12-06222165c35f, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="在CLion中进行源码调试"><a href="#在CLion中进行源码调试" class="headerlink" title="在CLion中进行源码调试"></a>在CLion中进行源码调试</h3><p>由于不是原生的Linux环境，我在尝试从源码导入CMake项目的时候也卡了很久，最后按照<a target="_blank" rel="noopener" href="https://lin1997.github.io/2020/07/19/debug-openjdk-on-ubuntu.html">这篇文章</a>的流程完成了配置。</p>
<h4 id="CLion连接Ubuntu"><a href="#CLion连接Ubuntu" class="headerlink" title="CLion连接Ubuntu"></a>CLion连接Ubuntu</h4><p>打开CLion，左侧选择WSL，再选择New Project，然后根据指引操作。选择文件目录时选择刚才的JDK源码目录（即解压之后得到的目录）。之后CLion会自动开始在WSL里下载服务端并启动。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/5.png"></p>
<h4 id="创建自定义Build-Target"><a href="#创建自定义Build-Target" class="headerlink" title="创建自定义Build Target"></a>创建自定义Build Target</h4><p>点击IDE右上角的齿轮，选择Settings，左边找到Custom Build Targets，点击“+”新建一个Build Target，Toolchain选择Default，并填写Name。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/6.png"></p>
<p>然后点击Build或Clean右边的“…”，新建两个External Tools：</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/7.png"></p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/8.png"></p>
<p>新建完后把make填到Build里，make clean填到Clean里。</p>
<h4 id="创建自定义Run-x2F-Debug-configuration"><a href="#创建自定义Run-x2F-Debug-configuration" class="headerlink" title="创建自定义Run&#x2F;Debug configuration"></a>创建自定义Run&#x2F;Debug configuration</h4><p>点击这个位置的Edit Configurations，并新建一个Custom Build Application。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/9.png"></p>
<p>Target选择刚才自定义的Build Target，Executable选择编译出来的JDK（刚才查看version时执行的那个程序），Program arguments可以先填一个-version测试一下。下面的build记得删掉。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/10.png"></p>
<p>至此配置完成。</p>
<h4 id="测试运行、打断点"><a href="#测试运行、打断点" class="headerlink" title="测试运行、打断点"></a>测试运行、打断点</h4><p>完成以上配置之后，右上角的Run和Debug应该已经变成绿色的了。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/11.png"></p>
<p>点击Run，可以发现输出了JDK的版本信息。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/12.png"></p>
<p>接下来测试断点功能。JVM的入口函数是<code>src/java.base/share/native/libjli/java.c</code>文件下的<code>JavaMain(void * _args)</code>函数。在这个函数打上断点后点击右上角的Debug，程序就会在断点处停止运行，并看到我们传入的参数信息。</p>
<p><img src="https://cyclohexatriene.github.io/images/JDK/13.png"></p>
<hr>
<h3 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h3><h4 id="Long-time-no-see"><a href="#Long-time-no-see" class="headerlink" title="Long time no see"></a>Long time no see</h4><p>又有快一年没更新了。去年暑假在上海实习，回来之后彻底从e人变成了i人，没事就喜欢宅着。顺利拿了转正offer，人生的下一个阶段就是在上海当牛马了。现在又开始觉得自己没有什么可以失去的了，孩子我无敌了。上个学期一直在摆烂，最近肝完了毕业论文的初稿，趁着还算是有一点点学习的状态学一点以后工作可能用得上的东西。希望这段时间能经常更新吧。</p>
<h4 id="没事听点歌（橘子海-夏日漱石）"><a href="#没事听点歌（橘子海-夏日漱石）" class="headerlink" title="没事听点歌（橘子海 - 夏日漱石）"></a>没事听点歌（橘子海 - 夏日漱石）</h4><audio controls>
    <source src="https://cyclohexatriene.github.io/music/夏日漱石.mp3" type="audio/mpeg">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/06/26/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/26/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Spring Boot快速上手指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-26 20:54:58 / 修改时间：22:18:56" itemprop="dateCreated datePublished" datetime="2023-06-26T20:54:58+08:00">2023-06-26</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>本文是 <a target="_blank" rel="noopener" href="https://spring.io/quickstart">Spring官方提供的教程</a> 的中文译文。中文互联网上能查的教程质量都不怎么样（起码对于完全0基础的萌新来说），有的没头没尾的，有的细节上（比如JDK版本和Maven的pom.xml文件中的父项目版本号不兼容等）没说清楚，给萌新留下了巨大的坑。在踩了一个下午 + 半个晚上的坑之后，笔者终于下定决心去Spring官网啃官方的英文教程。虽然很不想看英文，但是看了之后发现其实也没那么难，于是决定顺手翻译成中文，顺便穿插一点自己的理解。希望能帮到后来的萌新。碎碎念结束，下面正式开始。</p>
<h3 id="你将做什么"><a href="#你将做什么" class="headerlink" title="你将做什么"></a>你将做什么</h3><p>通过本教程，你将会创建一个经典的“Hello, World!”接口，所有浏览器都可以通过URL访问这个接口并得到响应。你可以在URL中设定你的名字，接口就会用更加友好的方式来会响应你。</p>
<h3 id="你需要准备什么"><a href="#你需要准备什么" class="headerlink" title="你需要准备什么"></a>你需要准备什么</h3><ol>
<li><strong>一个你喜欢的IDE</strong></li>
</ol>
<p>比较热门的选择有Intellij IDEA、Spring Tools、Visual Studio Code、Eclipse和很多其他的。</p>
<ol start="2">
<li><strong>一个JDK</strong></li>
</ol>
<p>我们推荐<a target="_blank" rel="noopener" href="https://bell-sw.com/pages/downloads/#/java-17-lts">BellSoft Liberica JDK</a> version 17。</p>
<blockquote>
<p>译者注：IDE方面，相对而言使用IDEA的人更多。我使用的是VSCode。IDEA确实更加智能，甚至过于智能了。我更喜欢在IDE中编辑完毕后敲命令行的感觉，这让我能更好地把握我每一步都做了什么事，不至于被IDE一股脑地包办，稀里糊涂地完成了项目，总觉得这样学习效果不好。JDK方面，我的环境是Oracle的JDK20。</p>
</blockquote>
<h2 id="第一步：新建一个Spring-Boot项目"><a href="#第一步：新建一个Spring-Boot项目" class="headerlink" title="第一步：新建一个Spring Boot项目"></a>第一步：新建一个Spring Boot项目</h2><p>用<a target="_blank" rel="noopener" href="http://start.spring.io/">start.spring.io</a>这个网站来创建一个Web项目。在”Dependencies”里面找到并添加Spring Web这个依赖。选完之后点击”Generate”按钮，浏览器会自动开始下载一个zip文件，将其解压到你的工作目录中。</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_spring_init.png"/></center>

<p>通过这个网站生成的项目会包含Spring Boot，一个不需要很多代码和配置就可以让你的应用运行Spring的框架。Spring Boot是创建Spring项目最快且最热门的途径。</p>
<h2 id="第二步：添加代码"><a href="#第二步：添加代码" class="headerlink" title="第二步：添加代码"></a>第二步：添加代码</h2><p>在你的IDE中打开项目，并且定位到 <code>src/main/java/com/example/demo</code> 文件夹下的 <code>DemoApplication.java</code> 这个文件，并为文件添加以下额外的方法和注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是通过Spring Boot来创建”Hello, World”这个简单的网络服务所需要的全部代码了。</p>
<p>我们刚刚添加的 <code>hello()</code> 方法可以接受一个String型的变量 <code>name</code> ，将其和单词 <code>&quot;Hello&quot;</code> 拼在一起后返回。所以如果你在请求中设置 <code>name</code> 为 <code>&quot;Amy&quot;</code> ，程序的响应就会是 <code>&quot;Hello Amy!&quot;</code>。</p>
<p>注解 <code>@RestController</code> 告诉Spring这段代码描述了一个需要能通过网络访问的端口。</p>
<p>注解 <code>@GetMapping(&quot;/hello&quot;)</code> 告诉Spring要使用上面定义的 <code>hello()</code> 方法来响应被发送到地址 <code>http://localhost:8080/hello</code> 的请求。</p>
<p>最后， 注解 <code>@RequestParam</code> 告诉Spring请求里需要有一个值，也就是上面提到的 <code>name</code> ，但是如果请求里没有这么一个值，那就默认采用单词 <code>&quot;World&quot;</code> 来代替。</p>
<h2 id="第三步：试试看"><a href="#第三步：试试看" class="headerlink" title="第三步：试试看"></a>第三步：试试看</h2><p>让我们来构建并运行这个程序。打开一个命令行（或终端）并且设置工作目录为你的项目存放的目录。我们可以通过以下命令来构建并运行这个应用：</p>
<p><strong>MacOS&#x2F;Linux:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew bootRun</span><br></pre></td></tr></table></figure>

<p><strong>Windows:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\gradlew.bat bootRun</span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：上面应该是默认采用了gradle wrapper作为构建工具了。我使用的是maven wrapper，对应的命令为 .\mvnw spring-boot:run。maven在构建过程中可能需要从远程仓库下载依赖项，国内访问可能会卡，一时不行的话可以等一会儿再试试。</p>
</blockquote>
<p>你应该看到类似的输出：</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_mvnw.png"/></center>

<p>上面的最后两行字告诉我们Spring已经在运行了。Spring Boot内置的Apache Tomcat正在作为这个项目的Web服务器运行，并且正在监听 <code>localhost</code> 的 <code>8080</code> 端口。打开你的浏览器，并在顶部的地址栏输入 <code>http://localhost:8080/hello</code> 。你应该得到这样一个很友好的响应：</p>
<center><img src="https://cyclohexatriene.github.io/images/quickstart_result.png"/></center>

<h2 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h2><p>如果你在上面的URL的末尾加上 <code>?name=Amy</code> 应该发生什么事呢？</p>
<blockquote>
<p>当然是显示 Hello, Amy! 了。</p>
</blockquote>
<hr>
<h2 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h2><h4 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h4><p>好久没更新博客了。跌跌撞撞结束了春招，拿到了算是相当不错的offer，然后摆了两个月。虽然和当初决心转码时追求WLB的初心有所偏离，但在这个就业形势下已经很不容易了。接下来要狠狠加班了。大概率要转Java岗，所以也在临阵磨枪学起了Spring Boot，不得不说还是Go的Gin简单。主打一个多才多艺。</p>
<h3 id="没事听点歌（温和治疗-明明想了又想又假装没有想）"><a href="#没事听点歌（温和治疗-明明想了又想又假装没有想）" class="headerlink" title="没事听点歌（温和治疗 - 明明想了又想又假装没有想）"></a>没事听点歌（温和治疗 - 明明想了又想又假装没有想）</h3><p>确实还是现场效果更炸一点。</p>
<audio controls>
    <source src="https://cyclohexatriene.github.io/music/明明想了又想又假装没有想.mp3" type="audio/mpeg">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">腾讯（魔方工作室）一面面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 00:07:43 / 修改时间：00:08:08" itemprop="dateCreated datePublished" datetime="2023-03-10T00:07:43+08:00">2023-03-10</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-聊一聊智能指针"><a href="#1-聊一聊智能指针" class="headerlink" title="1. 聊一聊智能指针"></a>1. 聊一聊智能指针</h3><p>智能指针的作用是管理一个指针，避免申请的空间忘记释放导致内存泄漏。智能指针本质上是一个类模板，当超出了类的作用域时，类就会自动调用析构函数回收资源。C++里有四种智能指针：<code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code>,和<code>weak_ptr</code>，其中<code>auto_ptr</code> 在C++11版本已经被废弃。</p>
<ul>
<li><code>auto_ptr</code> （已废弃）</li>
</ul>
<p><code>auto_ptr</code> 采用了所有权模式，后创建的指针会剥夺前面的指针的所有权。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure>

<p>p2会剥夺p1对指针的所有权，此时再访问p1就会出错。所以<code>auto_ptr</code>存在潜在的内存崩溃问题。</p>
<ul>
<li><code>unique_ptr</code> （代替<code>auto_ptr</code>）</li>
</ul>
<p><code>unique_ptr</code>采用独占式拥有概念，保证同一时间内之有一个智能指针可以指向该对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure>

<p>上面的代码无法通过编译，保证在编译期就将问题排查出来。此外，<code>unique_ptr</code>允许被一个临时的右值赋值，例如将上述第二行代码改为<code>p2 = unique_ptr&lt;int&gt;(new int(1))</code>，则可以通过编译，因为这样不会造成悬挂指针的情况。</p>
<ul>
<li><code>shared_ptr</code></li>
</ul>
<p><code>shared_ptr</code>采用共享式拥有概念，多个<code>shared_ptr</code>可以指向相同的对象，并且只有最后一个指向它的<code>shared_ptr</code>被销毁时才会释放它占有的资源。</p>
<ul>
<li><code>weak_ptr</code></li>
</ul>
<p><code>weak_ptr</code>是为了避免两个<code>shared_ptr</code>互相引用，导致其计数永远不会归零、资源永远不会被释放的死锁现象而引入的。它不控制对象的生命周期，不会改变计数器。<code>weak_ptr</code>没有重载<code>*</code>和<code>-&gt;</code>运算符，所以不能直接访问和修改引用的对象（可以通过<code>lock()</code>函数将其转化为<code>shared_ptr</code>然后再访问），但可以访问对象的引用数量等信息，它更像是一个<code>shared_ptr</code>的监控者。</p>
<h3 id="2-能不能自己实现一个shared-ptr？"><a href="#2-能不能自己实现一个shared-ptr？" class="headerlink" title="2. 能不能自己实现一个shared_ptr？"></a>2. 能不能自己实现一个<code>shared_ptr</code>？</h3><p>自己封装一个类模板就行。需要实现构造函数和析构函数、拷贝构造函数和拷贝赋值函数，还有重载一些指针的操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_cnt</span> &#123;</span></span><br><span class="line"><span class="comment">//计数器类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_cnt</span>() :<span class="built_in">cnt</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* ptr;</span><br><span class="line">	shared_cnt* cb;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数和析构函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(T* p = <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ptr = p;</span><br><span class="line">		cb = <span class="keyword">new</span> <span class="built_in">shared_cnt</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">my_shared_ptr</span>() &#123;</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针操作</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr; <span class="comment">// p-&gt;m被解释为(p.operator-&gt;())-&gt;m，所以返回值应该是一个指针。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(<span class="keyword">const</span> my_shared_ptr&amp; other) &#123;</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 赋值函数</span></span><br><span class="line">	my_shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> my_shared_ptr&amp; other) &#123;</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;old ptr has been deleted.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cb-&gt;<span class="built_in">getCnt</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-虚函数是什么原理？"><a href="#3-虚函数是什么原理？" class="headerlink" title="3. 虚函数是什么原理？"></a>3. 虚函数是什么原理？</h3><p>每个包含虚函数的类（或者继承了包含虚函数的基类）都有一个自己的虚函数表，这个表是一个编译时就确定的静态数组。虚函数表包含了指向每个虚函数的函数指针。而编译器会在基类中定义一个隐藏的指针<code>vptr</code>，这是一个指向虚函数表的指针，在类对象创建的时候<code>vptr</code> 会设置成指向类的虚函数表。所以含有虚函数的类会多分配一个指针的大小。如果子类重写了基类的虚函数，就会将虚函数表中的函数指针覆盖为自己重写的函数以供调用。</p>
<p>如以下例子所示，基类<code>Base</code>有<code>function1</code>和<code>function2</code>两个函数，子类<code>D1</code>和<code>D2</code>分别重写了这两个函数。所以在<code>D1</code>的对象的虚函数表中，<code>function1</code>会指向自己重写的新函数，而<code>function2</code>会指向基类的<code>function2</code>，<code>D2</code>同理。</p>
<img src="https://cyclohexatriene.github.io/images/virtual-func.jpg">

<p>还有一个很巧妙的事情。看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D1 d1;</span><br><span class="line">Base *dPtr = &amp;d1;</span><br></pre></td></tr></table></figure>

<p>因为 <code>dPtr</code> 是 <code>Base</code> 类型指针，它只指向 <code>d1</code> 对象的 <code>Base</code> 类型部分(即，指向 <code>d1</code> 对象中的 <code>Base</code> 子对象)，而  <code>vptr</code> 也在 <code>Base</code> 类型部分。所以 <code>dPtr</code> 可以访问 <code>Base</code> 类型部分中的 <code>vptr</code> 。同时，这里注意，  <code>dPtr-&gt;__vptr</code> 指向的是 <code>D1</code> 的虚拟函数表，这是在 <code>d1</code> 初始化时就确定的。所以结果，尽管 <code>dPtr</code> 是 <code>Base</code>  类型指针，但它能够访问 <code>D1</code> 的虚函数表。</p>
<p>所以当调用<code>dPtr-&gt;function1()</code>时，发生了这些事情：</p>
<ol>
<li>程序识别到<code>function1()</code>是一个虚函数。</li>
<li>程序使用 <code>dPtr-&gt;__vptr</code> 获取到了 <code>D1</code> 的虚函数表。</li>
<li>它在 <code>D1</code> 的虚函数表中寻找可以调用的 <code>function1() </code>版本，这里是 <code>D1::function1()</code>。</li>
<li>所以这次调用实际调用的就是<code>D1::function1()</code>。</li>
</ol>
<h3 id="4-含有虚函数的类的size问题？"><a href="#4-含有虚函数的类的size问题？" class="headerlink" title="4. 含有虚函数的类的size问题？"></a>4. 含有虚函数的类的size问题？</h3><ul>
<li>如果类里只有一个虚函数，那这个类有多大？</li>
</ul>
<p>只要有虚函数就会创建一个虚表指针，一个指针是4字节，所以这个类就是4字节。</p>
<ul>
<li>那要是有两个虚函数呢？</li>
</ul>
<p>那也是只有一个虚表指针，还是4字节。</p>
<ul>
<li>扩展：类的内存布局</li>
</ul>
<p>在没有继承的情况下，类的内存布局会根据声明顺序依次排布，且会有对齐现象，默认对齐大小为类内最大的基础类型大小。成员函数存在代码区，不占类的内存。静态变量存在全局存储区，也不占类的内存。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时A对象的<code>short a</code>本来占两个字节，为了与<strong>最大的基础类型</strong><code>int</code>对齐，接下来的2字节将会跳过，然后是<code>int b</code>的4字节，一共是8字节。如果将<code>func1</code>设置成虚函数，则会在类的头部出现一个虚表指针，那么A就是12字节。</p>
<p>虚函数表会单独对齐，例如，将<code>b</code>改为<code>double</code>类型，类内存的布局就是：4字节虚表指针，4字节对齐，2字节<code>short a</code>，6字节对齐，然后是8字节的<code>double b</code>，一共是24字节。</p>
<ul>
<li>一个空类是多大？</li>
</ul>
<p>一个空类理论上来说是0字节，但是编译器会为其加入1字节，这是为了它的每个对象都有独一无二的地址。例如对象a的地址是0x00000000，那对象b的地址就不可能再是0x00000000，起码也是0x00000001，这就意味着对象a占据了1字节的空间。 当另一个类继承了这个空类时，这个空类的内存就变回0字节了。</p>
<h3 id="5-虚函数和纯虚函数的区别？"><a href="#5-虚函数和纯虚函数的区别？" class="headerlink" title="5. 虚函数和纯虚函数的区别？"></a>5. 虚函数和纯虚函数的区别？</h3><p>虚函数由基类定义一个默认的函数，子类在继承时可以重写一个自己专属版本，也可以直接采用基类的默认函数；而纯虚函数则由基类给出声明，子类<strong>必须</strong>自行完成定义。含有纯虚函数的类被称作抽象类，无法直接创建实例，需要被继承后创建子类的实例。</p>
<h3 id="6-你的项目里用到了大量的锁，有什么优化方式吗？"><a href="#6-你的项目里用到了大量的锁，有什么优化方式吗？" class="headerlink" title="6. 你的项目里用到了大量的锁，有什么优化方式吗？"></a>6. 你的项目里用到了大量的锁，有什么优化方式吗？</h3><p>我的回答：我目前是获得一次锁只从队列中获取一个任务，可以设计成获得一次锁就从队列里获取若干个任务一起处理，这样可以均摊锁的成本。</p>
<h3 id="7-有没有可能完全不用锁？"><a href="#7-有没有可能完全不用锁？" class="headerlink" title="7. 有没有可能完全不用锁？"></a>7. 有没有可能完全不用锁？</h3><p>我的回答：可以加一层代理，由一个线程统一对任务队列进行管理，接到任务时主动指定某个线程并将其唤醒处理，不使用锁的机制抢任务处理。</p>
<h3 id="8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"><a href="#8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？" class="headerlink" title="8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"></a>8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？</h3><p>我的回答：不是很了解，可以加密，传输密文，或改用HTTPS。</p>
<h3 id="9-那你知道HTTPS的原理吗？"><a href="#9-那你知道HTTPS的原理吗？" class="headerlink" title="9. 那你知道HTTPS的原理吗？"></a>9. 那你知道HTTPS的原理吗？</h3><p>有点长，回头再来学。</p>
<h3 id="10-你知道内存分配的方式吗？比如malloc-x2F-jemalloc之类的"><a href="#10-你知道内存分配的方式吗？比如malloc-x2F-jemalloc之类的" class="headerlink" title="10. 你知道内存分配的方式吗？比如malloc&#x2F;jemalloc之类的"></a>10. 你知道内存分配的方式吗？比如malloc&#x2F;jemalloc之类的</h3><p>我的回答：只知道malloc，但知道操作系统级别的内存分配方式，面试官让我展开说说，我就说了一些操作系统的内存管理方式，比如说连续静态分配、动态分区、分页式之类的。追问如何减少碎片</p>
<ul>
<li><p><code>malloc(size_t size)</code>：C&#x2F;C++标准库的函数，分配<code>size</code>字节的内存，返回所分配区域的第一个字节的指针，如果内存不够就返回NULL。不会对空间进行初始化。 </p>
</li>
<li><p><code>calloc(size_t num, size_t size)</code>：为一个大小是<code>num</code>的数组分配内存，每个元素的大小是<code>size</code>，返回指向所分配区域的第一个字节的指针。如果内存不够就返回NULL。每个元素会被初始化为0。</p>
</li>
<li><p><code>alloca(size_t size)</code>：在栈上申请内存，不需要free函数释放。很快，适合小的分配。但是可移植性差，不推荐使用。</p>
</li>
<li><p><code>tcmalloc</code>：google的内存分配管理模块</p>
</li>
<li><p><code>jemalloc</code>：BSD的内存分配管理模块</p>
</li>
</ul>
<h3 id="11-HTTP报文由哪些结构组成？消息报头都有哪些字段？"><a href="#11-HTTP报文由哪些结构组成？消息报头都有哪些字段？" class="headerlink" title="11. HTTP报文由哪些结构组成？消息报头都有哪些字段？"></a>11. HTTP报文由哪些结构组成？消息报头都有哪些字段？</h3><p><strong>请求报文：</strong></p>
<ol>
<li><p>请求行（请求方法、URL、HTTP版本）</p>
</li>
<li><p>请求头部（客户端信息、目标Host、需求语言等信息）</p>
</li>
<li><p>空行</p>
</li>
<li><p>请求数据（POST的信息）</p>
</li>
</ol>
<p><strong>响应报文：</strong></p>
<ol>
<li><p>状态行（HTTP版本、状态码）</p>
</li>
<li><p>消息报头（必备Content-Type和Content-Length，还有服务器信息、文件最后更新时间、压缩算法等）</p>
</li>
<li><p>空行</p>
</li>
<li><p>响应正文（HTML代码、图片数据等）</p>
</li>
</ol>
<h3 id="12-HTTP状态码有哪些？"><a href="#12-HTTP状态码有哪些？" class="headerlink" title="12. HTTP状态码有哪些？"></a>12. HTTP状态码有哪些？</h3><ol>
<li><p>信息响应，以1开头。例如<code>100 Continue</code>，POST方法可能会将请求头和请求数据分成两个数据包进行发送，服务器收到请求头时就会先响应一个<code>100 Continue</code>表示请求头没有问题，可以继续发请求数据。</p>
</li>
<li><p>成功响应，以2开头。例如<code>200 OK</code>。</p>
</li>
<li><p>重定向消息，以3开头。例如<code>301 Moved Permanently</code>，表示请求资源的URL已被永久更改，会在响应中给出新的URL。还有<code>307 Temporary Redirect</code>和<code>308 Permanent Redirect</code>等。</p>
</li>
<li><p>客户端错误响应，以4开头，例如<code>400 Bad Request</code>、<code>403 Forbidden</code>、<code>404 Not Found</code></p>
</li>
<li><p>服务端错误响应，以5开头，例如<code>502 Bad Gateway</code>、<code>503 Service Unavailable</code>等。</p>
</li>
</ol>
<h3 id="13-Linux环境下，程序出错，错误信息会记录在什么文件里？"><a href="#13-Linux环境下，程序出错，错误信息会记录在什么文件里？" class="headerlink" title="13. Linux环境下，程序出错，错误信息会记录在什么文件里？"></a>13. Linux环境下，程序出错，错误信息会记录在什么文件里？</h3><p>我答了个errno，面试官指出这是系统调用的错误信息；我说那我不知道了，我只见过stdout的错误信息，比如段错误之类的；面试官追问，那除了段错误还有什么呢，我回忆了一下说不知道了（其实还有算术错误，比如分母为0、无对应操作符、返回值类型有误、未定义变量&#x2F;函数、类型溢出等等）。</p>
<p>会存放在core文件里，可以使用gdb打开core文件（指令为<code>gdb [exec file]] [core file]</code>，例如 <code>gdb ./a.o ./core</code>）。指定core文件进入gdb后，gdb会自动显示如下的错误信息，包括错误的类型、出错的线程、代码所在行以及具体是哪句代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./a.o&#x27;.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">24     cout &lt;&lt; 1/a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>where</code>和<code>bt</code>指令查看，但不会显示出具体的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) where</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong></p>
<ol>
<li>使用<code>ulimit -c</code>查看core文件的最大大小，如果是0则不会生成core文件。如果指定文件大小，但生成的信息超过此大小，就会被裁剪而生成不完整的core文件，在调试此文件时gdb会提示错误。一般直接设置成<code>ulimit -c unlimited</code>就可以了。</li>
<li>如果要查看具体出错在哪行，使用g++编译时要加上<code>-g</code>获取调试信息，否则只会显示在哪个线程出错。</li>
<li>core文件的生成路径记录在<code>/proc/sys/kernel/core_pattern</code>这个文件里。</li>
</ol>
<h3 id="14-手撕代码"><a href="#14-手撕代码" class="headerlink" title="14. 手撕代码"></a>14. 手撕代码</h3><p>给定一个正整数N，打印出比N大的最小的“非重复数”（相邻数位不同，例如1120是重复数，1210是非重复数）。</p>
<p>测试用例：19901, 9901, 1120, 9</p>
<p><strong>思路：</strong>找到最高位的相邻数位相同的位置，对其进行处理（变得更大,必要时进位），剩下的用010101…填充即可。</p>
<p><strong>问题：</strong>如果使用测试用例219901，在一次进位后会变成22开头的数字，需要第二次进位。试图以循环方式处理，被面试官称为“缝缝补补”，很不优雅。</p>
<p><strong>解决方案：</strong>从右往左遍历，每扫到重复的就进行一次增加处理，直到全部相邻数位都不重复</p>
<p><strong>进阶：</strong>不使用string。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sin = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	num++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newNum = num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newSin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				num++;</span><br><span class="line">			&#125; <span class="keyword">while</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>);</span><br><span class="line">		newNum = num;</span><br><span class="line">			newSin = sin;</span><br><span class="line">		&#125;</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">		sin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; newNum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newSin; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i % <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="DLC-1-对象切片"><a href="#DLC-1-对象切片" class="headerlink" title="DLC.1 对象切片"></a>DLC.1 对象切片</h3><p><strong>对象切片：</strong>当一个函数的参数是<strong>按值传递</strong>的，且传递的对象类型是<strong>基类</strong>。当调用该函数时，传入派生类对象时，会自动向上转型，将对象转换成基类对象，并删除派生类中新增的任何成员。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">114</span>, <span class="number">514</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    A a = b;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">114</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of b: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的输出是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">addr of a: 010FF778</span><br><span class="line">addr of b: 010FF788</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>A a = b</code>这句代码中发生了对象切片。因为这里创建了一个新的A类对象，自然就创建了新的A类的虚表指针，指向基类的函数。但是注意，<strong>如果传递指针，则不会发生对象切片</strong>，因为没有调用类的构造函数，只是一个指针的复制或拷贝过程，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    A* a = b;</span><br><span class="line">    A* a1 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114</span>);</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">    a1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;addr of b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">addr of a: 00D809E8</span><br><span class="line">addr of b: 00D809E8</span><br><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br></pre></td></tr></table></figure>

<p>只有新创建的a1对象调用了基类的函数。</p>
<h3 id="DLC-2-静态联编和动态联编"><a href="#DLC-2-静态联编和动态联编" class="headerlink" title="DLC.2 静态联编和动态联编"></a>DLC.2 静态联编和动态联编</h3><p><strong>联编：</strong>将源代码中的函数调用解释为执行特定的函数代码块的过程称为函数名联编。意思就是，同一个名称的函数有多种，联编就是把调用和具体的实现进行链接映射的操作。</p>
<p>联编中，C++编译器在编译过程中完成的编译叫做<strong>静态联编</strong>。</p>
<p>但是重载、重写、虚函数使得静态联编变得困难。因为编译器不知道用户将选择哪种类型的对象，执行具体哪一块代码。所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这个过程被称为<strong>动态联编</strong>。</p>
<p><strong>编译器对非虚方法使用静态联编，对虚方法使用动态联编。</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v) :<span class="built_in">a</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;function A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) :<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;function B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* a)</span> </span>&#123;</span><br><span class="line">    a-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114514</span>);</span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="built_in">f</span>(b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is A</span><br><span class="line">this is B</span><br><span class="line">function A</span><br><span class="line">function A</span><br></pre></td></tr></table></figure>

<p>可以看到，编译器对虚函数进行了动态联编，分别调用了基类和子类的函数；而对非虚函数进行了静态联编，总是调用基类的函数。</p>
<h3 id="DLC-3-公有、保护、私有继承"><a href="#DLC-3-公有、保护、私有继承" class="headerlink" title="DLC.3 公有、保护、私有继承"></a>DLC.3 公有、保护、私有继承</h3><p>继承时，我们要选择继承方式，例如：<code>class B : public A</code>就是B以公有继承的方式继承了A。</p>
<p>而这个<code>public</code>修饰的是从类A继承来的对象在B里的新权限。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果类B对其进行<strong>公有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为公有对象。</p>
<p>如果类B对其进行<strong>保护继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为保护对象。</p>
<p>如果类B对其进行<strong>私有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为私有对象；<code>c</code>被继承为私有对象。</p>
<p><strong>规律：</strong>以最严格的权限为准。</p>
<h3 id="DLC-4-类和结构体的区别"><a href="#DLC-4-类和结构体的区别" class="headerlink" title="DLC.4 类和结构体的区别"></a>DLC.4 类和结构体的区别</h3><p>在C的时代，struct不能包含函数。</p>
<p>但是在C++时代，struct不仅可以包含函数，还可以包含虚函数、可以继承和多态、可以使用模板，甚至跟class可以互相继承，几乎和class没有区别。C++保留struct的一大原因（甚至可能是唯一原因）就是为了兼容C。</p>
<p>但是区别还是有的。</p>
<ol>
<li>struct的成员默认是public；class的成员默认是private。</li>
<li>struct默认是公有继承；class默认是私有继承。默认继承方式以子类为准。</li>
<li>struct不能定义模板参数，class可以（就像typename）。</li>
</ol>
<p>还有一个细节共同点：struct和class如果定义了构造函数，就都不能用大括号初始化（<code>A a&#123;5&#125;;</code>），如果没定义构造函数，<strong>且成员变量都是公有的</strong>，就可以使用大括号初始化。</p>
<hr>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>牛客网 C++面经</p>
<p><a href=https://zhuanlan.zhihu.com/p/356879347>C++ | 虚函数表及虚函数执行原理详解</a></p>
<p><a herf=https://zhuanlan.zhihu.com/p/354849447>C++手把手带你实现一个智能指针</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/380147337>浅析C++类的内存布局</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/105714609>C&#x2F;C++内存分配函数差异及高效率内存分配库总结</a></p>
<p><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status>HTTP 响应状态码</a></p>
<p><a href=https://zhuanlan.zhihu.com/p/135454697>GET 和 POST 的区别？</a></p>
<p><a href=https://blog.csdn.net/qq_42570601/article/details/114842320>使用GDB(一)：分析core.xxx文件常用方法</a></p>
<p><a href=https://blog.csdn.net/m0_56104219/article/details/123244825>c++中的对象切片</a></p>
<p><a href=https://www.cnblogs.com/scyq/p/12709629.html>C++ 动态联编和静态联编</a></p>
<p><a href=https://blog.csdn.net/sxtdzj/article/details/81906504>C++公有继承，保护继承，私有继承的区别</a></p>
<p><a href=https://blog.csdn.net/alidada_blog/article/details/83419757>【C++】struct和class的区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/01/18/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/18/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Gin学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-18 15:44:57 / 修改时间：16:04:37" itemprop="dateCreated datePublished" datetime="2023-01-18T15:44:57+08:00">2023-01-18</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Gin是基于Go开发的Web微框架，相当简洁好用。</p>
<h1 id="Download-Gin"><a href="#Download-Gin" class="headerlink" title="Download Gin"></a>Download Gin</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>需要 <code>import &quot;github.com/gin-gonic/gin&quot;</code>。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><ul>
<li><code>gin.Default()</code></li>
</ul>
<p>生成一个gin实例。</p>
<h2 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h2><p>HTTP请求中有<strong>GET，POST，PUT，PATCH，DELETE</strong>和<strong>OPTIONS</strong>等方法，还有一个<strong>Any</strong>可以匹配所有方法。</p>
<ul>
<li><code>GET(path, func)</code></li>
</ul>
<p>声明一个“路由”（即被请求的路径<code>path</code>），当客户端（浏览器）使用HTTP的GET方法向服务器请求位于<code>path</code>的页面时，触发func所定义的函数进行处理。这个func只有一个参数，即<code>gin.Context</code>类型的指针，这个指针指向的地址空间储存了一些对传来的HTTP报文解析后的信息，解析过程是gin封装好的。<code>POST(path, func)</code> 等也同理。</p>
<p>此外，Gin还支持分组路由功能。例如有一组路由均为<code>/a</code>打头，则可以写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := r.Group(<span class="string">&quot;/a&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	v1.GET(<span class="string">&quot;/b&quot;</span>, defaultHandler) <span class="comment">// GET /a/b</span></span><br><span class="line">	v1.GET(<span class="string">&quot;/c&quot;</span>, defaultHandler) <span class="comment">// GET /a/c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>有时请求的URL中会承载一定的信息，这部分信息可以使用<code>Param()</code>或<code>Query()</code>获取。</p>
<ul>
<li><code>Param(string)</code></li>
</ul>
<p>如果要使用<code>Param()</code>方法，则声明的URL中需要包含对应的“占位符”（不清楚学名，笔者自己这么称呼的），用冒号来表示。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	c.String(http.StatusOK, <span class="string">&quot;hello, %s&quot;</span>, name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，如果浏览器向服务器请求<code>&quot;/user/dzc&quot;</code>，则服务端会返回字符串<code>&quot;hello, dzc&quot;</code>。</p>
<ul>
<li><code>Query(string)</code></li>
</ul>
<p>如果要使用<code>Query()</code>方法，则实际请求的URL中需要包含问号<code>?</code>，将需要发送到服务端的信息以键值对的形式放在问号后面，键值对之间使用<code>&amp;</code>分隔。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/welcome&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	first := c.Query(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">	last := c.Query(<span class="string">&quot;last&quot;</span>)</span><br><span class="line">	out := <span class="string">&quot;hello, &quot;</span> + first + last</span><br><span class="line">	c.String(http.StatusOK, out)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，如果浏览器向服务器请求<code>&quot;/welcome?first=d&amp;last=zc&quot;</code>，则服务器回返回字符串<code>hello, dzc</code>。</p>
<p>另一些时候，浏览器的数据会以POST方法发送给服务器，这部分数据可以使用<code>PostForm()</code>来解析。</p>
<ul>
<li><code>PostForm(string)</code> &amp; <code>DefaultPostForm(string, string)</code></li>
</ul>
<p>用POST方法提交的表单数据也是以键值对的形式表示的，可以使用<code>PostForm()</code>将其解析出来，而该方法的另一个变种<code>DefaultPostForm()</code>则允许使用者在未解析到所需字段时设置一个默认结果，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	login := c.PostForm(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">	passwd := c.DefaultPostForm(<span class="string">&quot;pass&quot;</span>,<span class="string">&quot;defaultpasswd&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> login == <span class="string">&quot;3200104203&quot;</span> &amp;&amp; passwd == <span class="string">&quot;4203&quot;</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Login successful.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Wrong password.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><p>Gin支持返回多种类型的数据，如字符串、JSON、HTML页面等。</p>
<ul>
<li><code>String(int, string)</code></li>
</ul>
<p><code>String()</code>用于返回一个字符串，第一个参数是返回的HTTP状态码，第二个参数是要返回的字符串内容。例如：<code>c.String(http.StatusOK, &quot;hello world&quot;)</code>。</p>
<ul>
<li><code>JSON(int, gin.H)</code></li>
</ul>
<p><code>JSON()</code>用于返回一个JSON对象，第一个参数是返回的HTTP状态码，第二个参数是要返回的JSON内容。<code>gin.H</code>类型实际上就是<code>map[string]interface&#123;&#125;</code>，其中空接口可以代表任何类型（所有类型均视为实现了一个空接口），所以<code>gin.H</code>类的实例相当于一个JSON对象。</p>
<ul>
<li><code>HTML(int, string, gin.H)</code></li>
</ul>
<p><code>HTML()</code>用于返回一个HTML页面，第一个参数是返回的HYTTP状态码，第二个参数是要返回的页面的路径，第三个参数是需要嵌入到HTML中的数据（如果HTML中出现<code>&#123;&#123;.msg&#125;&#125;</code>，即Gin的模板语法，则会用<code>&quot;this is a message from server.&quot;</code>代替）。在使用这个函数之前，需要用<code>LoadHTMLGlob()</code>或<code>LoadHTMLFiles()</code>将HTML页面文件从硬盘加载进内存中，其中前者可以一次加载整个目录下的所有文件，而后者则单独加载某一个文件。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r.LoadHTMLFiles(<span class="string">&quot;root/index.html&quot;</span>) <span class="comment">// 或 r.LoadHTMLGlob(&quot;root/*&quot;)</span></span><br><span class="line">r.GET(<span class="string">&quot;/reg&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;this is a message from server.&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件，顾名思义就是在浏览器和服务器中间的一层东西。而这层东西可以对浏览器发来的请求进行拦截并进行一些预处理，例如权限验证等。此外，中间件还可以在服务器完成处理后、向客户端发送响应前进行一些处理（如添加统一的响应头等）。Gin有内置一些中间件，如默认使用的<code>Logger()</code>和<code>Recovery()</code>。</p>
<ul>
<li>全局使用中间件<code>Use(func)</code></li>
</ul>
<p><code>Use()</code>方法用于全局使用中间件。例如：<code>r.Use(gin.Recovery())</code></p>
<ul>
<li>路由分组使用中间件</li>
</ul>
<p>在创建路由分组时可以添加该路由分组使用的中间件。</p>
<p>例如：<code>user := router.Group(&quot;user&quot;,gin.Recovery())</code> 。</p>
<ul>
<li>单个路由使用中间件</li>
</ul>
<p>在创建单个路由时也可以添加该路由使用的中间件。</p>
<p>例如：<code>r.GET(&quot;/&quot;,gin.Recovery(),DefaultHandler)</code> 。</p>
<ul>
<li>自定义中间件</li>
</ul>
<p>Gin规范了自定义中间件的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyMiddleware</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义中间件时，如果需要与服务端进行<strong>数据传递</strong>的话，可以使用<code>Set()</code>和<code>Get()</code>方法。</p>
<ul>
<li><code>Set(string, interface&#123;&#125;)</code></li>
</ul>
<p>使用<code>Set()</code>时，相当于为<code>gin.Context</code>设置了一个键值对。其中键必须是<code>string</code>类型的，而值可以是任意类型的。</p>
<ul>
<li><code>Get(string)</code></li>
</ul>
<p>使用<code>Get()</code>可以将之前<code>Set()</code>的值读取出来，其返回两个值，第一个是键对应的值，第二个是该键是否存在，用布尔类型表示。</p>
<p><code>Next()</code>方法可以划分中间件的前置和后置功能。<code>Next()</code>调用前的代码将在请求到达服务端之前进行，而<code>Next()</code>调用后的代码则会在服务端处理完毕后、正式向客户端发送响应前运行。</p>
<p><code>Abort()</code>方法可以拦截请求&#x2F;响应。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyMiddlewareForAuth := <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	login := c.PostForm(<span class="string">&quot;login&quot;</span>)</span><br><span class="line">	passwd := c.PostForm(<span class="string">&quot;pass&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> login == <span class="string">&quot;3200104203&quot;</span> &amp;&amp; passwd == <span class="string">&quot;4203&quot;</span> &#123;</span><br><span class="line">		c.Set(<span class="string">&quot;Authres&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.Set(<span class="string">&quot;Authres&quot;</span>, <span class="number">0</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Wrong password.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/register&quot;</span>, MyMiddlewareForAuth, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> val, exists := c.Get(<span class="string">&quot;Authres&quot;</span>); exists &amp;&amp; val == <span class="number">1</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;Login successful.&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.String(http.StatusOK, <span class="string">&quot;hello?\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://geektutu.com/post/quick-go-gin.html">https://geektutu.com/post/quick-go-gin.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151818857">https://zhuanlan.zhihu.com/p/151818857</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1585029">https://cloud.tencent.com/developer/article/1585029</a></p>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（Billie-Eilish-bad-guy）"><a href="#没事听点歌（Billie-Eilish-bad-guy）" class="headerlink" title="没事听点歌（Billie Eilish - bad guy）"></a>没事听点歌（Billie Eilish - bad guy）</h2><audio controls>
    <source src = "https://cyclohexatriene.github.io/music/bad guy.mp3">
</audio>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/12/14/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/14/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">离线查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-14 16:21:36 / 修改时间：17:53:08" itemprop="dateCreated datePublished" datetime="2022-12-14T16:21:36+08:00">2022-12-14</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久不见，刚好一个月没更新了。一个月里还发生了蛮多事的，单一个防疫政策就已经大变天了。希望能看到这句话的朋友们都能保护好自己，能晚不早，能阴不阳。</p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>在线</strong> 和 <strong>离线</strong> 可以简单地理解为<strong>对于所有的操作是否需要读入完毕</strong>。</p>
<p>在线算法的要求是，不用先知道所有的操作（如查询、修改等），一边读入一边执行，所有操作之间的独立性比较高。</p>
<p>而离线算法则相反，要求必须先知道所有的操作，再执行操作。这样的话，我们就有机会合理安排操作顺序，以更高的效率完成所有操作。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-1697-检查边长度限制的路径是否存在"><a href="#LeetCode-1697-检查边长度限制的路径是否存在" class="headerlink" title="LeetCode 1697. 检查边长度限制的路径是否存在"></a>LeetCode 1697. 检查边长度限制的路径是否存在</h2><p>给你一个 <code>n</code> 个点组成的无向图边集 <code>edgeList</code> ，其中 <code>edgeList[i] = [ui, vi, disi]</code> 表示点 <code>ui</code> 和点 <code>vi</code> 之间有一条长度为 <code>disi</code> 的边。请注意，两个点之间可能有 <strong>超过一条边</strong> 。</p>
<p>给你一个查询数组 <code>queries</code> ，其中 <code>queries[j] = [pj, qj, limitj]</code> ，你的任务是对于每个查询 <code>queries[j]</code> ，判断是否存在从 <code>pj</code> 到 <code>qj</code> 的路径，且这条路径上的每一条边都 <strong>严格小于</strong> <code>limitj</code> 。</p>
<p>请你返回一个 <strong>布尔数组</strong> <code>answer</code> ，其中 <code>answer.length == queries.length</code> ，当 <code>queries[j]</code> 的查询结果为 <code>true</code> 时， <code>answer</code> 第 <code>j</code> 个值为 <code>true</code> ，否则为 <code>false</code> 。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><img src="https://cyclohexatriene.github.io/images/1697_1.png"/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edgeList = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">16</span>]], queries = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：上图为给定的输入数据。注意到 <span class="number">0</span> 和 <span class="number">1</span> 之间有两条重边，分别为 <span class="number">2</span> 和 <span class="number">16</span> 。</span><br><span class="line">对于第一个查询，<span class="number">0</span> 和 <span class="number">1</span> 之间没有小于 <span class="number">2</span> 的边，所以我们返回 <span class="literal">false</span> 。</span><br><span class="line">对于第二个查询，有一条路径（<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span>）两条边都小于 <span class="number">5</span> ，所以这个查询我们返回 <span class="literal">true</span> 。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><img src="https://cyclohexatriene.github.io/images/1697_2.png"/>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edgeList = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">13</span>]], queries = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">14</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：上图为给定数据。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的第一反应是在线查询的思路，就是把每个 <code>query</code> 都当成独立的，然后再写一个函数判断是否可行，而这个函数的算法可能会采用BFS。后来觉得容易TLE，瞄了眼题解发现要用并查集。然后我就闷头写了个并查集，查询时，将边长度小于当前 <code>query</code> 限制距离的边的两个端点 <code>union</code> 起来，发现还是TLE。（有关并查集的内容可以查阅 <a href = "https://cyclohexatriene.github.io/2022/07/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/">这篇文章</a> 。）</p>
<p>然后仔细研究了题解，发现了离线查询这东西。因为题目的查询操作都是给定的，所以我们可以根据每个 <code>query</code>的距离限制对 <code>queries</code> 数组进行升序排序，同时也根据边的长度对 <code>edgeList</code> 进行升序排序，再按照新的<code>queries</code> 顺序进行操作。这样，限制距离更小的 <code>query</code> 操作起来就是限制距离更大的 <code>query</code> 的子集，跟在线查询比都不知道省到哪里去了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> root = <span class="built_in">find</span>(vec[a]);</span><br><span class="line">            vec[a] = root;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        vec[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">distanceLimitedPathsExist</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vec = vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">iota</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(queries.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(edgeList.<span class="built_in">begin</span>(), edgeList.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt;&amp; e1, vector&lt;<span class="keyword">int</span>&gt;&amp; e2) &#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">2</span>] &lt; e2[<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">seq</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(seq.<span class="built_in">begin</span>(), seq.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(seq.<span class="built_in">begin</span>(), seq.<span class="built_in">end</span>(), [&amp;queries](<span class="keyword">int</span> i1, <span class="keyword">int</span> i2) &#123;</span><br><span class="line">            <span class="keyword">return</span> queries[i1][<span class="number">2</span>] &lt; queries[i2][<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : seq) &#123;</span><br><span class="line">            <span class="keyword">while</span> (idx &lt; edgeList.<span class="built_in">size</span>() &amp;&amp; edgeList[idx][<span class="number">2</span>] &lt; queries[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(edgeList[idx][<span class="number">0</span>], edgeList[idx][<span class="number">1</span>]);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = (<span class="built_in">find</span>(queries[i][<span class="number">0</span>]) == <span class="built_in">find</span>(queries[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceLimitedPathsExist</span><span class="params">(n <span class="keyword">int</span>, edgeList [][]<span class="keyword">int</span>, queries [][]<span class="keyword">int</span>)</span> []<span class="title">bool</span></span> &#123;</span><br><span class="line">    vec := <span class="built_in">make</span>([]<span class="keyword">int</span>,n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> vec &#123;</span><br><span class="line">        vec[i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> find <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    find = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> vec[a] != a &#123;</span><br><span class="line">            vec[a] = find(vec[a])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec[a]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    union := <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        vec[find(a)] = find(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        queries[i] = <span class="built_in">append</span>(queries[i], i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Slice(edgeList,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeList[i][<span class="number">2</span>] &lt; edgeList[j][<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    sort.Slice(queries,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queries[i][<span class="number">2</span>] &lt; queries[j][<span class="number">2</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">bool</span>,<span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">var</span> idx <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        <span class="keyword">for</span> idx &lt; <span class="built_in">len</span>(edgeList) &amp;&amp; edgeList[idx][<span class="number">2</span>] &lt; query[<span class="number">2</span>] &#123;</span><br><span class="line">            union(edgeList[idx][<span class="number">0</span>],edgeList[idx][<span class="number">1</span>])</span><br><span class="line">            idx++</span><br><span class="line">        &#125; </span><br><span class="line">        res[query[<span class="number">3</span>]] = find(query[<span class="number">0</span>]) == find(query[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="入坑Golang"><a href="#入坑Golang" class="headerlink" title="入坑Golang"></a>入坑Golang</h2><p>投实习的时候发现好多后端都要求用Go开发，于是决定入坑。语法上过了一遍菜鸟教程，然后力扣上题也刷起来了，中等以下的题都是直接用Go写，今天的Hard用C++写了一遍之后再用Go写了一遍。Go的语法就像是C&#x2F;C++和Python的融合怪，取了二者之精华，还增加了一些C&#x2F;C++并没有但是很实用很酷炫的特性（比如for … range语法可以同时迭代下标和值），我很中意。但也有很多有些别扭的地方，比如不支持<code>set</code> ，只有 <code>map</code> ，虽然本质上差不多，也可以用 <code>map</code> 实现 <code>set</code> 的功能，但是用起来就是很麻烦。还没内置 <code>queue</code> 、 <code>stack</code> 之类的数据结构，甚至连 <code>min</code> 、 <code>max</code> 这种简单而又常用的函数都需要自己手搓。<del>STL真是绝绝子好用到跺jiojio。</del></p>
<h2 id="没事听点歌（Coldplay-Viva-La-Vida）"><a href="#没事听点歌（Coldplay-Viva-La-Vida）" class="headerlink" title="没事听点歌（Coldplay - Viva La Vida）"></a>没事听点歌（Coldplay - Viva La Vida）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/Viva La Vida.mp3">
</audio>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/11/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/14/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">折半搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-14 22:20:28 / 修改时间：22:42:07" itemprop="dateCreated datePublished" datetime="2022-11-14T22:20:28+08:00">2022-11-14</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>折半搜索（meet-in-the-middle），虽然听起来有点像二分查找，但是其实是两种不同的算法。一般针对数组元素组合的暴力搜索，复杂度会来到 <code>O(2^n)</code>，稍微有点数据量就容易TLE。而折半搜索则是一种取巧的方式，一次只爆搜一半的数据，爆搜两次，然后将两次爆搜的结果组合起来，就可以提升很多效率。不过复杂度依然是指数级别的。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-805-数组的均值分割"><a href="#LeetCode-805-数组的均值分割" class="headerlink" title="LeetCode 805. 数组的均值分割"></a>LeetCode 805. 数组的均值分割</h2><p>给定你一个整数数组 <code>nums</code></p>
<p>我们要将 <code>nums</code> 数组中的每个元素移动到 <code>A</code> 数组 或者 <code>B</code> 数组中，使得 <code>A</code> 数组和 <code>B</code> 数组不为空，并且 <code>average(A) == average(B)</code> 。</p>
<p>如果可以完成则返回<code>true</code> ， 否则返回 <code>false</code> 。</p>
<p><strong>注意：</strong>对于数组 <code>arr</code> ,  <code>average(arr)</code> 是 <code>arr</code> 的所有元素的和除以 <code>arr</code> 长度。</p>
<p><strong>提示：</strong>1 &lt;&#x3D; nums.length &lt;&#x3D; 30</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 我们可以将数组分割为 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>] 和 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 他们的平均值都是<span class="number">4.5</span>。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>分割后的两个数组的平均数相同，那么把它们和回去，平均数肯定不变，所以两个数组的平均数等于原数组的平均数。所以我们只需要判断原数组是否存在一个<strong>平均数和原数组的平均数相等</strong>的非空子数组就行了。</p>
<p>本题数组最长长度会有30，如果直接二进制暴力枚举的话，需要枚举 <code>2^30</code> 次，指定会TLE。所以就可以使用折半搜索，先搜索前半部分，然后把搜索结果存进哈希表里，然后再搜剩下一半。在搜剩下一半时，每枚举到一种组合，就再枚举它和前半部分组合后的组合的长度和这个长度对应的理论元素总和，然后去哈希表中查找这个理论总和是否真实存在，如果存在就说明我们找到了可行解，返回 <code>true</code> 即可。这样我们最多只需要枚举两个 <code>2^15</code> 就行，数量级一下子就下来了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">splitArraySameAverage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; map;<span class="comment">/* cnt,sum */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">int</span> tsum = <span class="number">0</span>, tcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    tsum += nums[idx];</span><br><span class="line">                    tcnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map[tsum].<span class="built_in">insert</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = n - m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; r); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">int</span> tsum = <span class="number">0</span>, tcnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    tsum += nums[m + idx];</span><br><span class="line">                    tcnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">max</span>(<span class="number">1</span>,tcnt); j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j * sum % n != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> t = j * sum / n;</span><br><span class="line">                <span class="keyword">if</span> (map[t - tsum].<span class="built_in">count</span>(j - tcnt)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（金玟岐-岁月神偷）"><a href="#没事听点歌（金玟岐-岁月神偷）" class="headerlink" title="没事听点歌（金玟岐 - 岁月神偷）"></a>没事听点歌（金玟岐 - 岁月神偷）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/岁月神偷.mp3">
</audio>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/11/13/WebServer%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/13/WebServer%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">WebServer记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-13 14:37:00 / 修改时间：16:05:05" itemprop="dateCreated datePublished" datetime="2022-11-13T14:37:00+08:00">2022-11-13</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好久没来更新了，从上次更新到现在忙了很多事情，而且忙了半天也不知道自己忙了些啥，很丧。做的为数不多的比较扎实的事情就是仿照着GitHub上的<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">开源项目</a>写了一个WebServer，目前已经完成了一个可以传输静态页面的Demo，还需要优化以及添加一些别的功能。先记录一下，免得以后忘了。</p>
<hr>
<h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><p>程序采用的是“半同步半反应堆式”的线程池，也就是：</p>
<ul>
<li><p>主线程负责监听文件描述符上发生的事件，并针对事件进行IO。</p>
</li>
<li><p>子线程负责处理逻辑，解析收到的HTTP报文，准备好要发送的数据，并通知主线程可以进行IO了。</p>
</li>
</ul>
<p>具体实现时，程序分为了若干个模块：线程同步模块、日志模块、MySQL连接池模块、HTTP处理模块、mmap模块、线程池模块、epoll监听模块。</p>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>是整个项目最简单的一部分，也是上手完成的第一个部分，就是把Linux底层提供的一些线程同步机制进行了封装，使用的时候会更加方便一些。把<code>init()</code>和<code>destroy()</code>分别写进了构造函数和析构函数，随取随用，让代码更加简洁，应该也属于所谓的<code>RAII</code>机制。</p>
<blockquote>
<p>RAII机制：资源获取就是初始化（Resource Acquisition Is Initialization），这是一种管理资源的方式，C++保证任何情况下，已构造的对象最终都会销毁，即它的析构函数一定会被调用。所以只要把资源的获取和释放分别封装进一个类的构造函数和析构函数，就可以保证资源不会发生“泄露”。</p>
</blockquote>
<h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>();</span><br><span class="line">    ~<span class="built_in">locker</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span>* <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>();</span><br><span class="line">    ~<span class="built_in">cond</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>();</span><br><span class="line">    <span class="built_in">sem</span>(<span class="keyword">int</span> num);</span><br><span class="line">    ~<span class="built_in">sem</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>条件变量与信号量的区别：个人理解中，信号量sem本质上是一个计数的功能，post就是让信号量加一，wait就是让信号量减一，post和wait调用先后问题不大；而条件变量cond则必须先wait再signal或broadcast，否则就会发生丢失信号的现象，特定情况下甚至会造成死锁。另外，信号量可以在进程之间共享，而条件变量只能在进程内部、线程之间共享。</p>
</blockquote>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志系统实现了同步写日志和异步写日志两种模式。同步写日志就是调用了写日志函数之后就等着写完了才退出函数，异步写日志则是在日志系统中维护了一个“生产者-消费者”模型，写日志的函数只负责生产任务，而真正的写入工作则由异步线程完成。为了实现这个“生产者-消费者”模型，我编写了一个阻塞队列，就是把STL中带有的队列模板进行进一步封装，让它的每一个操作都是线程安全的。这样生产者只管push，消费者只管pop就行了。</p>
<p>回到日志系统本身。日志类是在单例模式下编写的。所谓的单例模式，就是把这个类的构造函数和析构函数都私有化，只有类自己能调用，程序的其它部分不能创建新的对象；然后在这个类里<strong>静态地</strong>内置一个自己，保证整个程序只有这一个对象，并可通过类的<strong>静态</strong>方法来获取这个唯一对象。</p>
<h2 id="代码摘录："><a href="#代码摘录：" class="headerlink" title="代码摘录："></a>代码摘录：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    ~<span class="built_in">Log</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL连接池"><a href="#MySQL连接池" class="headerlink" title="MySQL连接池"></a>MySQL连接池</h1><p>由于建立和释放MySQL连接是非常消耗资源的，所以用到了临时建立连接太低效了，我们可以维护一个连接池，在初始化时建立一些连接，程序在需要时就可以直接从池里获得一个连接，用完还回来就行。同样采用单例的编写模式。连接池模块有两个类，一个是连接池本体，一个是<code>RAII</code>的接口，接口初始化时从池里获取连接，析构时自动归还。</p>
<h2 id="连接池本体声明："><a href="#连接池本体声明：" class="headerlink" title="连接池本体声明："></a>连接池本体声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connection_pool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">connection_pool</span>();</span><br><span class="line">    ~<span class="built_in">connection_pool</span>();</span><br><span class="line">    string user;</span><br><span class="line">    string passwd;</span><br><span class="line">    string DatabaseName;</span><br><span class="line">    <span class="keyword">bool</span> close_log; <span class="comment">/* If true, the connection pool won&#x27;t write logs. */</span></span><br><span class="line">    <span class="keyword">int</span> max_conn;</span><br><span class="line">    locker m_locker;</span><br><span class="line">    list&lt;MYSQL*&gt; connList;</span><br><span class="line">    sem m_sem; <span class="comment">/* sem &gt; 0 means there is free connections. */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> connection_pool* <span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> connection_pool instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string user, string password, string name, <span class="keyword">int</span> maxconn, <span class="keyword">bool</span> close_log = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">MYSQL* <span class="title">getConnection</span><span class="params">()</span></span>; <span class="comment">/* Get a free connection from pool. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">releaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">/* Return a connection into the pool. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyPool</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="HTTP处理"><a href="#HTTP处理" class="headerlink" title="HTTP处理"></a>HTTP处理</h1><p>这个模块暂时只实现了传输静态页面，图片、文件的传输还有待研究。类里有一个<code>process()</code>函数，用于处理输入、获得待写输出。<code>process()</code>函数由线程池异步调用，处理好再通知主线程进行一个数据的写。</p>
<h2 id="声明：-1"><a href="#声明：-1" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">/*private*/</span></span><br><span class="line">    <span class="keyword">char</span> state_line[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> headers[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http</span>();</span><br><span class="line">    <span class="built_in">http</span>(<span class="keyword">char</span> pack[], <span class="keyword">int</span> fd);</span><br><span class="line">    ~<span class="built_in">http</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> clntfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> package[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span> <span class="comment">/* iov[0]: state_line; iov[1]: headers; iov[2]: resource to be got */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里用到了<code>iovec</code>，就是分布式IO，可以把需要IO的部分（用起始地址和偏移量表示）存进一个向量里，然后调用<code>readv()</code>或<code>writev()</code>一次性读写多个缓冲区，相当优雅。</p>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h1><p>对底层的mmap API进行了封装。mmap还没用明白，所以暂时还没用进程序里，不过理论上可以大幅度提高程序的IO性能。</p>
<blockquote>
<p>mmap是一种内存映射文件的方式。普通的文件读写，需要先open()，把文件在读取进操作系统内核的内存里，然后再read()和write()，将内核的内存拷贝进用户态的内存里，造成了效率的浪费；而使用mmap，则可以让内核和用户共享一块内存，省去了第二步的拷贝，更加高效。</p>
</blockquote>
<h2 id="声明：-2"><a href="#声明：-2" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mmap_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">void</span> *start; <span class="comment">/* The start of mmap. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mmap_file</span>();</span><br><span class="line">    <span class="built_in">mmap_file</span>(string path);</span><br><span class="line">    ~<span class="built_in">mmap_file</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openFile</span><span class="params">(string path)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">getStart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输入一个文件路径，获取这个文件mmap后的起始内存和偏移量。不过好像iovec不能直接用，还没来得及研究和调试。</p>
<h1 id="线程池模块"><a href="#线程池模块" class="headerlink" title="线程池模块"></a>线程池模块</h1><p>复用了日志模块的阻塞队列，将已经完成了读操作的http对象加入到工作队列中，由线程池维护的若干个线程竞争获取任务，然后在子线程中异步地完成处理，并注册对应文件描述符上的写事件，通知主线程进行一个写。同样采用单例模式编写。</p>
<h2 id="声明：-3"><a href="#声明：-3" class="headerlink" title="声明："></a>声明：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>();</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>; <span class="comment">/* Call process() in an infinite loop. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_t</span>* m_threads;</span><br><span class="line">    block_queue&lt;http*&gt; workq;</span><br><span class="line">    <span class="keyword">int</span> m_thread_number;</span><br><span class="line">    sem m_sem;</span><br><span class="line">    locker m_locker;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(http* request)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> threadpool* <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> threadpool instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="EPOLL-监听"><a href="#EPOLL-监听" class="headerlink" title="EPOLL 监听"></a>EPOLL 监听</h1><p>EPOLL是一种IO多路复用的模型，类似的模型还有SELECT和POLL，但他俩都不如EPOLL好使。在我写的项目里就以单例模式维护了一个EPOLL的监听池，封装了一些API，方便程序直接调用。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>简单地理解就是在一个线程同时监听一大堆文件描述符是否有可写事件和可读事件发生，这样程序可以同时处理来自多个事件流中的事件。</p>
<h2 id="SELECT、POLL和EPOLL的区别"><a href="#SELECT、POLL和EPOLL的区别" class="headerlink" title="SELECT、POLL和EPOLL的区别"></a>SELECT、POLL和EPOLL的区别</h2><p>最早被写出来的IO多路复用模型是SELECT，实现思路也非常耿直：就是维护一个数组，调用<code>wait()</code>的时候就去遍历一遍这个数组，看看每个文件描述符是否有事件发生，如果有的话就拎出来告诉调用者。因为用的是数组，所以监听的文件描述符数量有上限，大概是1024个。</p>
<p>而POLL所作出的改进是用链表代替了普通的数组，突破了1024个的上限。但由于还是采用遍历的方式来判断是否有事件发生，依然是线性的复杂度。</p>
<p>然后EPOLL就闪亮登场了。EPOLL底层维护了一棵红黑树和一个链表，红黑树用于保存文件描述符，链表用于保存已经发生了事件的文件描述符。与前两代模型不同，EPOLL不是主动地去遍历，而是给每个文件描述符设置一个“回调函数”，当有事件发生时就自动调用，把文件描述符存进链表中，这样就可以不用遍历了，调用<code>wait()</code>时只需要返回那个链表就行，时间复杂度是常量级的。</p>
<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="网抑云（五月天、孙燕姿-温柔-MaydayBlue20th）"><a href="#网抑云（五月天、孙燕姿-温柔-MaydayBlue20th）" class="headerlink" title="网抑云（五月天、孙燕姿 - 温柔 #MaydayBlue20th）"></a>网抑云（五月天、孙燕姿 - 温柔 #MaydayBlue20th）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/温柔.mp3">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/10/23/%E6%AF%8F%E6%97%A5Hard-Day-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/23/%E6%AF%8F%E6%97%A5Hard-Day-12/" class="post-title-link" itemprop="url">每日Hard - Day 12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-23 14:19:24 / 修改时间：14:25:55" itemprop="dateCreated datePublished" datetime="2022-10-23T14:19:24+08:00">2022-10-23</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年10月23日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>不完全是就是完全不是</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>随机化</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#LeetCode-381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a>LeetCode 381. O(1) 时间插入、删除和获取随机元素 - 允许重复</h2><p><code>RandomizedCollection</code> 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。</p>
<p>实现 <code>RandomizedCollection</code> 类:</p>
<ul>
<li><code>RandomizedCollection()</code>初始化空的 <code>RandomizedCollection</code> 对象。</li>
<li><code>bool insert(int val)</code> 将一个 <code>val</code> 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>bool remove(int val)</code> 如果存在，从集合中移除一个 <code>val</code> 项。如果该项存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。注意，如果 <code>val</code> 在集合中出现多次，我们只删除其中一个。</li>
<li><code>int getRandom()</code> 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 <strong>线性相关</strong> 。</li>
</ul>
<p>您必须实现类的函数，使每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>
<p><strong>注意：</strong>生成测试用例时，只有在 <code>RandomizedCollection</code> 中 <strong>至少有一项</strong> 时，才会调用 <code>getRandom</code> 。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;RandomizedCollection&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;getRandom&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;getRandom&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">2</span>], [], [<span class="number">1</span>], []]</span><br><span class="line">输出</span><br><span class="line">[null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedCollection collection = <span class="keyword">new</span> <span class="built_in">RandomizedCollection</span>();<span class="comment">// 初始化一个空的集合。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">1</span>);<span class="comment">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">1</span>);<span class="comment">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span></span><br><span class="line">collection.<span class="built_in">insert</span>(<span class="number">2</span>);<span class="comment">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span></span><br><span class="line">collection.<span class="built_in">getRandom</span>();<span class="comment">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span></span><br><span class="line">collection.<span class="built_in">remove</span>(<span class="number">1</span>);<span class="comment">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span></span><br><span class="line">collection.<span class="built_in">getRandom</span>();<span class="comment">// getRandom 应有相同概率返回 1 和 2 。</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>是我最喜欢的数据结构运用题。这里有一个小技巧，就是一般<code>vector</code>是不允许<code>O(1)</code>时间复杂度的随机删除的，但是本题中我们不在乎用到的<code>vector</code>里元素的顺序是怎么样的，那么我们就可以把需要删除的元素和末位元素进行一个位置互换，然后我们就能直接在<code>O(1)</code>时间复杂度下<code>pop_back()</code>了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; map;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedCollection</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        map[val].<span class="built_in">insert</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        nums.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (map[val].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[val].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> torm = *map[val].<span class="built_in">begin</span>();</span><br><span class="line">            map[val].<span class="built_in">erase</span>(torm);</span><br><span class="line">            map[nums.<span class="built_in">back</span>()].<span class="built_in">insert</span>(torm);</span><br><span class="line">            map[nums.<span class="built_in">back</span>()].<span class="built_in">erase</span>(nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(nums[torm], nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            nums.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rndidx = <span class="built_in">rand</span>() % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[rndidx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/10/22/pthread-h-%E5%BA%93%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/pthread-h-%E5%BA%93%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">pthread.h 库（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-22 14:48:23 / 修改时间：14:50:20" itemprop="dateCreated datePublished" datetime="2022-10-22T14:48:23+08:00">2022-10-22</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="互斥量：pthread-mutex系列"><a href="#互斥量：pthread-mutex系列" class="headerlink" title="互斥量：pthread_mutex系列"></a>互斥量：pthread_mutex系列</h2><ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
</ul>
<p>初始化一个互斥量，即第一个参数指向的<code>mutex</code>。一个互斥量必须初始化了之后才能用。</p>
<ul>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li>
</ul>
<p>顾名思义，就是删除一个互斥量，释放它的内存。</p>
<ul>
<li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li>
<li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
</ul>
<p>给互斥量上锁和解锁。如果需要上锁的互斥量已经被别的线程锁住了，那调用<code>pthread_mutex_lock()</code>的线程就会一直被阻塞直到那个互斥量被解锁，然后这个线程再获得锁。上面三个函数都是成功返回0，否则返回错误编号。如果不希望线程被阻塞，那可以用下面这个函数：</p>
<ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li>
</ul>
<p>这个函数会尝试对互斥量加锁，如果锁没被锁上，它就锁上这个锁；如果锁已经被锁住了，那么这个函数就会返回<code>EBUSY</code>。这个函数在避免死锁这件事上有很大帮助（如果不能取得全部的一系列锁，不是干等着而是把已经取得的锁都释放掉，避免跟另一个线程死锁）。</p>
<ul>
<li><code>int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);</code></li>
</ul>
<p>在某个时间前阻塞等待获得锁，超过这个时间就返回错误码<code>ETIMEDOUT</code>。</p>
<h2 id="读写锁：pthread-rwlock系列"><a href="#读写锁：pthread-rwlock系列" class="headerlink" title="读写锁：pthread_rwlock系列"></a>读写锁：pthread_rwlock系列</h2><p>读写锁与互斥量类似，但是它支持更高的并行性。它有三种状态：读模式下加锁、写模式下加锁和不加锁。当读写锁是写加锁时，无法被别的线程读、写加锁；当读写锁是读加锁时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞。读写锁非常适合对数据结构读的次数远大于写的情况。</p>
<ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li>
<li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li>
</ul>
<p>这两个函数分别用于初始化一个读写锁和销毁一个读写锁以释放它的内存。如果成功，返回0；否则，返回错误编号。</p>
<ul>
<li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></li>
</ul>
<p>这三个函数分别对一个读写锁进行读加锁、写加锁和解锁操作。如果成功，返回0；否则，返回错误编号。</p>
<ul>
<li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);</code></li>
<li><code>int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);</code></li>
</ul>
<p>就是读写锁版的<code>trylock()</code>和<code>timedlock()</code>。</p>
<h2 id="条件变量：pthread-cond系列"><a href="#条件变量：pthread-cond系列" class="headerlink" title="条件变量：pthread_cond系列"></a>条件变量：pthread_cond系列</h2><ul>
<li><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li>
<li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li>
</ul>
<p>这两个函数分别用于初始化和销毁一个条件变量。如果成功，返回0；否则，返回错误编号。</p>
<ul>
<li><code>int pthread_cond_wait(pthread_cond_t *restreict cond, pthread_mutex_t *restrict mutex);</code></li>
<li><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);</code></li>
</ul>
<p>这两个函数用于等待条件变量变为真。而第二个函数则是带有超时的版本。这两个函数都需要自带一个锁上的互斥量，这是为了保证检查条件变量到线程进入休眠等待条件改变这两个操作之间的操作是原子的。因为发信号的接收信号的进程往往会有一些公共的资源（比如生产者-消费者模型，会有一段任务队列是公用的），为了保证这些线程在访问这些公共资源的时候是原子性的，所以需要上锁。那么就有可能发生这样的情况：</p>
<blockquote>
<p>消费者获得锁，然后去读取任务队列，发现是空的，所以要等待生产者生产出任务，然后发送信号；</p>
<p>而生产者在向任务队列中写入任务前也需要获得锁，这就造成了一个死锁现象。</p>
</blockquote>
<p>为了避免这种情况，消费者在进入睡眠等待之前，要释放锁，让生产者去获得锁并生产出任务；生产者生产出任务并唤醒消费者后，消费者要再次获得锁并读取任务队列。</p>
<p>那么一来二去的，人们就发现还不如直接把这些上锁解锁的操作直接集成进<code>pthread_cond_wait()</code>里来的方便，于是这个函数就多了一个互斥量的参数了。</p>
<p>就这么干说有点抽象，可以看看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58838318">这篇文章</a>，写的相当详细，赞。</p>
<ul>
<li><code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
<li><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
</ul>
<p>这两个函数用于向某个信号量发出条件满足的信号，第一个函数至少能唤醒一个等待该条件的线程，而第二个能唤醒所有等待该条件的所有线程。如果成功，返回0；否则，返回错误编号。</p>
<p>还有一个要注意的点是我们要用while而不是if来判断条件，因为如果有多个消费者存在的话，可能某个消费者被唤醒后还没来得及获得锁，任务就已经被其它消费者处理完了。</p>
<h2 id="屏障：pthread-barrier系列"><a href="#屏障：pthread-barrier系列" class="headerlink" title="屏障：pthread_barrier系列"></a>屏障：pthread_barrier系列</h2><p>屏障是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有合作的线程都达到某一点，然后从该点继续执行。<code>pthread_join()</code>就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有线程达到屏障后可以接着工作。</p>
<ul>
<li><code>int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count);</code></li>
<li><code>int pthread_barrier_destroy(pthread_barrier_t *barrier);</code></li>
</ul>
<p>这两个函数分别用于屏障的初始化和销毁，如果成功，返回0；否则，返回错误编号。在初始化函数中，第三个参数<code>count</code>可以指定允许所有线程继续运行前，必须到达屏障的线程数目。</p>
<ul>
<li><code>int pthread_barrier_wait(pthread_barrier_t *barrier);</code></li>
</ul>
<p>这个函数表示线程已经完成工作，正在等待其他线程赶上来。如果成功，返回0或者<code>PTHREAD_BARRIER_SERIAL_THREAD</code>；否则，返回错误编号。只有第一个成功返回<code>wait()</code>会返回<code>PTHREAD_BARRIER_SERIAL_THREAD</code>，其余都返回<code>0</code>。这样特殊一点的线程就可以作为主线程工作在其他所有线程已完成的工作上。</p>
<p>一旦到达屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。如果需要改变计数值，就需要<code>destroy()</code>后重新<code>init()</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="环己三烯"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">环己三烯</p>
  <div class="site-description" itemprop="description">万里长征人未还</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">环己三烯</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'UsSNtA9GJ5h8tGViWaV97qbO-9Nh9j0Va',
      appKey     : 'J83xwqE3YCKgWOy0dIBrad1s',
      placeholder: "莫西莫西？",
      avatar     : 'hide',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://ussnta9g.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
