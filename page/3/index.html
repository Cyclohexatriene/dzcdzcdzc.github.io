<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cyclohexatriene.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="万里长征人未还">
<meta property="og:type" content="website">
<meta property="og:title" content="环己三烯的冬眠舱">
<meta property="og:url" content="http://cyclohexatriene.github.io/page/3/index.html">
<meta property="og:site_name" content="环己三烯的冬眠舱">
<meta property="og:description" content="万里长征人未还">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="环己三烯">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cyclohexatriene.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>环己三烯的冬眠舱</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">环己三烯的冬眠舱</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天天网抑云，偶尔读点书。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-comment-board">

    <a href="/comment-board" rel="section">留言板</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/09/15/%E6%AF%8F%E6%97%A5Hard-Day-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/15/%E6%AF%8F%E6%97%A5Hard-Day-4/" class="post-title-link" itemprop="url">每日Hard - Day 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-15 21:45:01" itemprop="dateCreated datePublished" datetime="2022-09-15T21:45:01+08:00">2022-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:34:39" itemprop="dateModified" datetime="2022-10-08T19:34:39+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年9月15日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>否（差一点点！）</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>动态规划Again</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-1771-由子序列构造的最长回文串的长度"><a href="#LeetCode-1771-由子序列构造的最长回文串的长度" class="headerlink" title="LeetCode 1771. 由子序列构造的最长回文串的长度"></a>LeetCode 1771. 由子序列构造的最长回文串的长度</h2><p>给你两个字符串 <code>word1</code> 和 <code>word2</code> ，请你按下述方法构造一个字符串：</p>
<ul>
<li>从 <code>word1</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence1</code> 。</li>
<li>从 <code>word2</code> 中选出某个 <strong>非空</strong> 子序列 <code>subsequence2</code> 。</li>
<li>连接两个子序列 <code>subsequence1 + subsequence2</code> ，得到字符串。</li>
</ul>
<p>返回可按上述方法构造的最长 <strong>回文串</strong> 的 <strong>长度</strong> 。如果无法构造回文串，返回 <code>0</code> 。</p>
<p>字符串 <code>s</code> 的一个 <strong>子序列</strong> 是通过从 <code>s</code> 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。</p>
<p><strong>回文串</strong> 是正着读和反着读结果一致的字符串。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;cacb&quot;</span>, word2 = <span class="string">&quot;cbba&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">&quot;ab&quot;</span> ，从 word2 中选出 <span class="string">&quot;cba&quot;</span> ，得到回文串 <span class="string">&quot;abcba&quot;</span> 。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;ab&quot;</span>, word2 = <span class="string">&quot;ab&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：从 word1 中选出 <span class="string">&quot;ab&quot;</span> ，从 word2 中选出 <span class="string">&quot;a&quot;</span> ，得到回文串 <span class="string">&quot;aba&quot;</span> 。</span><br></pre></td></tr></table></figure>

<h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">&quot;aa&quot;</span>, word2 = <span class="string">&quot;bb&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法按题面所述方法构造回文串，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>怎么Hard题这么多动态规划啊。而且与回文串有关的题题号也恰好是回文的，有点巧妙。</p>
<p>一开始的思路是把<code>word2</code>给reverse一下，然后通过动态规划算<code>word1</code>和<code>word2</code>的最长公共子序列，就可以得到答案了。但是遇到了下面这个测试用例WA了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string word1 = <span class="string">&quot;afaaadacb&quot;</span>;</span><br><span class="line">string word2 = <span class="string">&quot;ca&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>WA后初步认为是两个串不一样长导致的，所以添加了平衡字符串长度的代码，然后发现并不是长度的原因。还是得把两个串合在一起dp，并只在两个子串都不为空时更新答案。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.<span class="built_in">length</span>(), n2 = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> n = n1 + n2;</span><br><span class="line">        string word = word1 + word2;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> res = (word[n1 - <span class="number">1</span>] == word[n1]) ? <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) dp[i][i + <span class="number">1</span>] = (word[i] == word[i + <span class="number">1</span>]) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt; n; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + l &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + l;</span><br><span class="line">                <span class="keyword">if</span> (word[i] == word[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; n1 &amp;&amp; j &gt;= n1) res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（Knock-2-dashstar-）"><a href="#没事听点歌（Knock-2-dashstar-）" class="headerlink" title="没事听点歌（Knock 2 - dashstar*）"></a>没事听点歌（Knock 2 - dashstar*）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/dashstar.mp3">
</audio>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/09/14/%E6%AF%8F%E6%97%A5Hard-Day-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/14/%E6%AF%8F%E6%97%A5Hard-Day-3/" class="post-title-link" itemprop="url">每日Hard - Day 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-14 12:19:17 / 修改时间：12:29:56" itemprop="dateCreated datePublished" datetime="2022-09-14T12:19:17+08:00">2022-09-14</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年9月14日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>否</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>暴力枚举、几何</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-149-直线上最多的点数"><a href="#LeetCode-149-直线上最多的点数" class="headerlink" title="LeetCode 149. 直线上最多的点数"></a>LeetCode 149. 直线上最多的点数</h2><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h2><p>对于点a,b,c，如果其中任意两点构成的直线斜率相同，则三点共线。我们可以枚举所有的点对，用哈希表记录斜率，则可以判断有多少个点出现在同一条直线上。</p>
<p>本题难点在于计算斜率需要用到除法，而浮点数的除法是存在误差的。为了避免这个误差，一共有两种思路：</p>
<ol>
<li>利用乘法来避免除法（把两个斜率相等的表达式用对角相乘法则化为两个乘法表达式相等）。</li>
<li>用字符串来哈希。</li>
</ol>
<p>本题我选择用第二个思路解。在计算斜率时通过最大公约数把分式约分为最间，保证相同斜率的直线能全部哈希在一起。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="keyword">int</span>&gt; map;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x2 = points[j][<span class="number">0</span>], y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> a = x1 - x2;</span><br><span class="line">                <span class="keyword">int</span> b = y1 - y2;</span><br><span class="line">                <span class="keyword">int</span> g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">                string key = <span class="built_in">to_string</span>(a / g) + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(b / g);</span><br><span class="line">                map[key]++;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, map[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, mx + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/09/13/%E6%AF%8F%E6%97%A5Hard-Day-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/13/%E6%AF%8F%E6%97%A5Hard-Day-2/" class="post-title-link" itemprop="url">每日Hard - Day 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-13 20:44:48" itemprop="dateCreated datePublished" datetime="2022-09-13T20:44:48+08:00">2022-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:34:20" itemprop="dateModified" datetime="2022-10-08T19:34:20+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年9月13日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>否</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>滑动窗口（或前缀和）、动态规划</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-689-三个无重叠子数组的最大和"><a href="#LeetCode-689-三个无重叠子数组的最大和" class="headerlink" title="LeetCode 689. 三个无重叠子数组的最大和"></a>LeetCode 689. 三个无重叠子数组的最大和</h2><p>给你一个整数数组 <code>nums </code>和一个整数 <code>k</code> ，找出三个长度为 <code>k</code> 、互不重叠、且全部数字和（<code>3 * k</code> 项）最大的子数组，并返回这三个子数组。</p>
<p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 <strong>0</strong> 开始）。如果有多个结果，返回字典序最小的一个。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：子数组 [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">5</span>] 对应的起始下标为 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>]。</span><br><span class="line">也可以取 [<span class="number">2</span>, <span class="number">1</span>], 但是结果 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>] 在字典序上更大。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1,2,1,2,1], k = 2</span><br><span class="line">输出：[0,2,4]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="滑动窗口-动态规划"><a href="#滑动窗口-动态规划" class="headerlink" title="滑动窗口 + 动态规划"></a>滑动窗口 + 动态规划</h2><p>看到多个子数组求和第一反应就是前缀和，后来看题解发现滑动窗口也可以，而且更省内存一点。</p>
<p>求完所有长度为<code>k</code>的子数组和后，可以维护一个<code>left</code>和一个<code>right</code>数组，其中<code>left</code> 存从左开始到当前位置最大的和，<code>right</code>存从右开始到当前位置最大的和。我们枚举处于中间位置的数组，再通过<code>left</code>和<code>right</code>快速检索与这个位置不冲突的左侧最大子数组和以及右侧最大子数组和，在枚举过程中不断更新结果就可以了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSumOfThreeSubarrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) cur += nums[i];</span><br><span class="line">        sum.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">            cur = cur + nums[i] - nums[i - k];</span><br><span class="line">            sum.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n, n - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &gt; sum[left[i - <span class="number">1</span>]]) left[i] = i;</span><br><span class="line">            <span class="keyword">else</span> left[i] = left[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &gt;= sum[right[i + <span class="number">1</span>]]) right[i] = i;</span><br><span class="line">            <span class="keyword">else</span> right[i] = right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n - k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mx &lt; sum[i] + sum[left[i - k]] + sum[right[i + k]]) &#123;</span><br><span class="line">                mx = sum[i] + sum[left[i - k]] + sum[right[i + k]];</span><br><span class="line">                res = &#123; left[i - k],i,right[i + k] &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="没事听点歌（One-Republic-Counting-Stars）"><a href="#没事听点歌（One-Republic-Counting-Stars）" class="headerlink" title="没事听点歌（One Republic - Counting Stars）"></a>没事听点歌（One Republic - Counting Stars）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/countingstars.mp3">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/09/12/%E6%AF%8F%E6%97%A5Hard-Day-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/12/%E6%AF%8F%E6%97%A5Hard-Day-1/" class="post-title-link" itemprop="url">每日Hard - Day 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-12 19:50:27 / 修改时间：20:31:21" itemprop="dateCreated datePublished" datetime="2022-09-12T19:50:27+08:00">2022-09-12</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><table style="text-align:center">
    <tr>
        <td>日期</td>
        <td>2022年9月12日</td>
    </tr>
    <tr>
        <td>是否独立完成</td>
        <td>是</td>
    </tr>
    <tr>
        <td>涉及算法</td>
        <td>动态规划</td>
    </tr>
</table>

<hr>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="LeetCode-174-地下城游戏"><a href="#LeetCode-174-地下城游戏" class="headerlink" title="LeetCode 174. 地下城游戏"></a>LeetCode 174. 地下城游戏</h2><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>
<table style="text-align:center">
    <tr>
        <td>-2 (K)</td>
        <td>-3</td>
        <td>3</td>
    </tr>
    <tr>
        <td>-5</td>
        <td>-10</td>
        <td>1</td>
    </tr>
    <tr>
        <td>10</td>
        <td>30</td>
        <td>-5 (P)</td>
    </tr>
</table>

<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>随机刷居然能刷到做过的题，我还想这题还能是Hard…</p>
<p>动态规划经典题，从右下角向左上角dp，每个单元格表示在能救到公主的前提下进入该单元格前所需的最低生命值。最后<code>dp[0][0] - dungeon[0][0]</code>就是最终答案（当然，小于等于<code>0</code>当<code>1</code>处理）。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = dp[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i + <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[i][n - <span class="number">1</span>] &lt;= <span class="number">0</span>) dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = dp[m - <span class="number">1</span>][i + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dp[m - <span class="number">1</span>][i] &lt;= <span class="number">0</span>) dp[m - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = dp[i][j + <span class="number">1</span>] - dungeon[i][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> b = dp[i + <span class="number">1</span>][j] - dungeon[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(a, b);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &lt;= <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>][<span class="number">0</span>] - dungeon[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span>  res &lt;= <span class="number">0</span> ? <span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="关于每日Hard"><a href="#关于每日Hard" class="headerlink" title="关于每日Hard"></a>关于每日Hard</h2><p>题已经刷了不少了，接下来打算加大刷题的难度。其实暑假期间就计划要每日一题Hard来着，后来没坚持几天就摸了。于是决定每次做完题来Blog打个卡，算是督促自己坚持刷题吧。也不是真的要每天做一题Hard，只能说在时间允许的前提下努力坚持吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/08/18/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">有限状态自动机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-18 20:13:41" itemprop="dateCreated datePublished" datetime="2022-08-18T20:13:41+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:29:51" itemprop="dateModified" datetime="2022-10-08T19:29:51+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>听名字就能大概猜出“有限状态自动机”是干嘛的了。</p>
<ul>
<li><p>有一个当前状态 <code>pre</code> </p>
</li>
<li><p>每轮循环输入一个 <code>cur</code> </p>
</li>
<li><p>有限状态自动机可以根据事先的定义来进行状态的转移</p>
</li>
</ul>
<p>有限状态自动机并不能降低算法的复杂度，但是可以让代码看起来非常简洁清爽，也不会写着写着就晕掉了。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h2><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>若干空格</p>
</li>
<li><p>一个 <strong>小数</strong> 或者 <strong>整数</strong></p>
</li>
<li><p>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></p>
</li>
<li><p>若干空格</p>
</li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</p>
</li>
<li><p>下述格式之一：</p>
<ol>
<li><p>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></p>
</li>
<li><p>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code>，后面再跟着至少一位数字</p>
</li>
<li><p>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</p>
</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p>
</li>
<li><p>至少一位数字</p>
</li>
</ol>
<p>部分<strong>数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li>
</ul>
<p>部分<strong>非数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li>
</ul>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;e&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;.&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;    .1  &quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先贴一段我第一次写时的代码，用的是暴力模拟，写半天自己都写晕了，到后面变量名字都开始乱七八糟了，因为不能一次性考虑到所有细节， 所以根据WA给的测试用例缝缝补补勉强通过。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stringstream ss;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        ss &lt;&lt; s;</span><br><span class="line">        ss &gt;&gt; ws;</span><br><span class="line">        <span class="keyword">if</span>(ss.<span class="built_in">peek</span>()==<span class="string">&#x27;+&#x27;</span> || ss.<span class="built_in">peek</span>()==<span class="string">&#x27;-&#x27;</span>) ss.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">bool</span> hasnum=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ss.<span class="built_in">peek</span>()))&#123;</span><br><span class="line">            ss.<span class="built_in">get</span>();</span><br><span class="line">            hasnum=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss.<span class="built_in">peek</span>()==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            ss.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">bool</span> hasnum2=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ss.<span class="built_in">peek</span>()))&#123;</span><br><span class="line">                ss.<span class="built_in">get</span>();</span><br><span class="line">                hasnum2=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasnum2 &amp;&amp; !hasnum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!hasnum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ss.<span class="built_in">peek</span>()==<span class="string">&#x27;e&#x27;</span> || ss.<span class="built_in">peek</span>()==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">            ss.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">bool</span> hasnum1=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(ss.<span class="built_in">peek</span>()==<span class="string">&#x27;+&#x27;</span> || ss.<span class="built_in">peek</span>()==<span class="string">&#x27;-&#x27;</span>) ss.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ss.<span class="built_in">peek</span>()))&#123;</span><br><span class="line">                ss.<span class="built_in">get</span>();</span><br><span class="line">                hasnum1=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasnum1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &gt;&gt; ws;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">peek</span>()==<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而使用有限状态自动机就可以让代码非常清晰。我们可以定义如下的状态：</p>
<img src="https://cyclohexatriene.github.io/images/FSM.png" width=500 />

<center><font size="2">图源：LeetCode @Krahets 前辈的题解</font></center>

<p>在代码中，我们使用数组+字典来储存上图。只有退出后的状态为 <code>2/3/7/8</code> 中的一个时，我们才认为输入的字符串为合法的数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stringstream ss;</span><br><span class="line">        ss &lt;&lt; s;</span><br><span class="line">        vector&lt;unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; states = &#123;</span><br><span class="line">            &#123; &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>&#125;,&#123; <span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>&#125;,&#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>&#125;,&#123; <span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>&#125; &#125; ,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>&#125;,&#123; <span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>&#125;, &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>&#125; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss.<span class="built_in">peek</span>() != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = ss.<span class="built_in">get</span>();</span><br><span class="line">            <span class="keyword">char</span> cur;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) cur = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) cur = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) cur = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) cur = c;</span><br><span class="line">            <span class="keyword">else</span> cur = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (states[pre].<span class="built_in">count</span>(cur) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = states[pre][cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre == <span class="number">2</span> || pre == <span class="number">3</span> || pre == <span class="number">7</span> || pre == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="天才操作"><a href="#天才操作" class="headerlink" title="天才操作"></a>天才操作</h2><p>13号回的学校。回校前精心挑选了一班快十几分钟的车次，然后当天到了宁波站了才发现终点站是杭州南，不是杭州东，少坐一站可不是快一点嘛。后来找乘务姐姐补了一站路。</p>
<img src="https://cyclohexatriene.github.io/images/ticket.png" width=400/>

<h2 id="新生要来报到了"><a href="#新生要来报到了" class="headerlink" title="新生要来报到了"></a>新生要来报到了</h2><p>明天新生就陆续要来报到了，我也该读大三了。没有人永远年轻，但永远有人年轻。</p>
<img src="https://cyclohexatriene.github.io/images/freshman.jpg" width=400/>

<h2 id="没事听点歌（Neck-Deep-Serpent）"><a href="#没事听点歌（Neck-Deep-Serpent）" class="headerlink" title="没事听点歌（Neck Deep - Serpent）"></a>没事听点歌（Neck Deep - Serpent）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/Serpent.mp3" type="audio/mpeg">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/07/26/%E8%B7%B3%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E8%B7%B3%E8%A1%A8/" class="post-title-link" itemprop="url">跳表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 21:21:21" itemprop="dateCreated datePublished" datetime="2022-07-26T21:21:21+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:36:12" itemprop="dateModified" datetime="2022-10-08T19:36:12+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>今天LeetCode的每日一题是设计一个跳表。跳表是一种类似链表的数据结构，可以实现时间复杂度为 <code>O(log n)</code> 的查找和插入，效率堪比红黑树。</p>
<p>常规的链表可以实现常数级时间复杂度的插入，但是查找某一个特定元素的元素却是线性的。而诸如数组和vector之类的简单线性的数据结构，虽然可以通过二分查找来实现 <code>O(log n)</code> 时间复杂度的查找，但是在某个特定位置插入一个元素需要把其后面所有元素都挪动一遍，牵一发而动全身。而AVL树、红黑树可以平衡插入和查找的效率，被广泛应用。今天刚学到的跳表也有相似的性质。</p>
<blockquote>
<p>插一个小故事。就前两天我在看《STL源码剖析》试图理解红黑树的时候还看到一段话，说普通的链表查找某一个特定元素是线性的，我就想这个作者也太菜了，你不能二分查找吗？后来仔细一想，才想起来原来链表是没法随机访问的，自然不能二分查找，是我太菜了。</p>
<p>后来还是看不懂红黑树是什么原理。但是跳表就好理解多了。在LeetCode评论区里看到一条，“想了半天要如何确定一个值应该占用几层的链表，然后你给我来个coin filp，我遭不住了，底层逻辑基于随机数，怪不得STL里没你”，笑死我了。</p>
</blockquote>
<p>扯了这么多，那么跳表到底是什么原理呢？用LeetCode上的一张图就可以看懂了。</p>
<p><img src="https://cyclohexatriene.github.io/images/skiplist.gif"></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找时从上往下依次找到每层小于目标值的最大的节点，然后依次往下查找，中间可以跳过很多个节点。因为可以有可以跳过节点这个性质，跳表查找的平均时间复杂度是<code>O(log n)</code> ，这个有大佬证明了，而我不是大佬所以我不会证明。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时也依次从上往下找插入的节点，第<code>0</code>层包含跳表内的所有元素，然后每个元素在插入时有<code>p</code>的概率可以加入到上面那层，<code>p</code> 一般被设置为 <code>1/2</code> 。没错，跳表的结构是随机出来的，就是这么草率。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-1206-设计跳表"><a href="#LeetCode-1206-设计跳表" class="headerlink" title="LeetCode 1206. 设计跳表"></a>LeetCode 1206. 设计跳表</h2><p>就是设计一个上述跳表，要求实现查找、插入和删除三个功能。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;Skiplist&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;erase&quot;</span>, <span class="string">&quot;erase&quot;</span>, <span class="string">&quot;search&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">0</span>], [<span class="number">4</span>], [<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">1</span>]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, <span class="literal">false</span>, null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Skiplist skiplist = <span class="keyword">new</span> <span class="built_in">Skiplist</span>();</span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">0</span>);   <span class="comment">// 返回 false</span></span><br><span class="line">skiplist.<span class="built_in">add</span>(<span class="number">4</span>);</span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">1</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">skiplist.<span class="built_in">erase</span>(<span class="number">0</span>);    <span class="comment">// 返回 false，0 不在跳表中</span></span><br><span class="line">skiplist.<span class="built_in">erase</span>(<span class="number">1</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">skiplist.<span class="built_in">search</span>(<span class="number">1</span>);   <span class="comment">// 返回 false，1 已被擦除</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表的节点类，把插入和删除的操作都集成进来了</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        vector&lt;Node* &gt; next = vector&lt;Node* &gt;(<span class="number">10</span>, <span class="literal">nullptr</span>);<span class="comment">//为了偷懒这里直接把十层链表的头尾节点都预留好了，内存击败百分五[ac01]</span></span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> v) :<span class="built_in">val</span>(v) &#123;&#125;;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node* nxt, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在当前节点后面插入节点nxt，level代表目前操作的层数</span></span><br><span class="line">            vector&lt;Node* &gt;&amp; cur = <span class="keyword">this</span>-&gt;next;</span><br><span class="line">            nxt-&gt;next[level] = cur[level];</span><br><span class="line">            cur[level] = nxt;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">erasenext</span><span class="params">(Node* nxt)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在整个跳表中移除节点nxt</span></span><br><span class="line">            vector&lt;Node* &gt;&amp; cur = <span class="keyword">this</span>-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur[i] == nxt) &#123;</span><br><span class="line">                    cur[i] = cur[i]-&gt;next[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//head和tail为头尾节点</span></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Skiplist</span>() &#123;</span><br><span class="line">        <span class="comment">//Skiplist类的构造函数，将head和tail进行初始化</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//初始状态head的十个指针均应指向tail</span></span><br><span class="line">            head-&gt;next[i] = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="comment">//从上往下依次找到每层比target小的最大节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next[i]-&gt;val &lt; target) cur = cur-&gt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最后一层的下一个节点的值不是target的话，那target一定不在跳表里。</span></span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next[<span class="number">0</span>]-&gt;val == target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*前半部分和search过程一样</span></span><br><span class="line"><span class="comment">        只是需要多用一个stack把路上遇到的节点都存起来 */</span></span><br><span class="line">        stack&lt;Node* &gt; stk;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next[i]-&gt;val &lt; num) cur = cur-&gt;next[i];</span><br><span class="line">            stk.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(num);<span class="comment">//创建新节点</span></span><br><span class="line">        cur-&gt;<span class="built_in">insert</span>(newnode, level);<span class="comment">//第0层含有跳表全部元素，所以必须加入</span></span><br><span class="line">        <span class="keyword">while</span> (level &lt; <span class="number">9</span> &amp;&amp; <span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//进行一次判定，有1/2的几率可以进入上一层</span></span><br><span class="line">            level++;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            stk.<span class="built_in">top</span>()-&gt;<span class="built_in">insert</span>(newnode, level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前半部分和add一样需要把路过的节点存起来</span></span><br><span class="line">        stack&lt;Node* &gt; stk;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next[i]-&gt;val &lt; num) cur = cur-&gt;next[i];</span><br><span class="line">            stk.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next[<span class="number">0</span>]-&gt;val != num) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果跳表里没有num就直接返回false</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*否则调用erase函数删除后面一个节点</span></span><br><span class="line"><span class="comment">            此处传入的是节点的指针，保证不会误伤别的具有相同值的节点 */</span></span><br><span class="line">            cur-&gt;<span class="built_in">erasenext</span>(cur-&gt;next[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="暑假生活"><a href="#暑假生活" class="headerlink" title="暑假生活"></a>暑假生活</h2><p>暑假在家真的宅烂了，今天跟两个初中同学去南虹吃了一整天。吃了臭豆腐、老长沙手工肠、颜记排骨、虾滑、两杯茶百道、KFC、炸串串，饱死了。</p>
<p><img src="https://cyclohexatriene.github.io/images/kfc.jpg"></p>
<h2 id="没事听点歌（胡歌-忘记时间）"><a href="#没事听点歌（胡歌-忘记时间）" class="headerlink" title="没事听点歌（胡歌 - 忘记时间）"></a>没事听点歌（胡歌 - 忘记时间）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/忘记时间.mp3" type="audio/mpeg">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/07/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">并查集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-08 15:44:33" itemprop="dateCreated datePublished" datetime="2022-07-08T15:44:33+08:00">2022-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:32:29" itemprop="dateModified" datetime="2022-10-08T19:32:29+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并查集是用来处理一些不相交集合的合并和查询问题，开始时每个元素都是一个集合，然后在处理中会依据一些规则来进行集合的合并。在逻辑上，并查集是由很多树组成的森林，而在实际的代码中，我们往往使用数组来储存，数组的下标表示树的节点，下标对应的元素表示该节点的父节点。另外，我们定义根节点的父节点是它自己。并查集的操作有：</p>
<ul>
<li><p>查询某个节点的根节点</p>
</li>
<li><p>合并两个集合</p>
</li>
</ul>
<hr>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先定义一个 <code>vector</code> 来表示并查集。在初始化时，我们将其中每个元素设为其对应下标的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="comment">//初始化代码</span></span><br><span class="line">vec.<span class="built_in">resize</span>(n, <span class="number">0</span>);<span class="comment">//n代表元素的数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) vec[i] = i;</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询指查询给定节点的根节点。若两个节点的根节点相同，则表示这两个节点在同一个集合里。在代码中，如果某个节点不是根节点（表现为元素与其对应的下标不相等），则递归地查找其父节点的根节点，并将其父节点直接修改为根节点以减少下次查找所需要的时间（称为“路径压缩”）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec[root] != root) vec[root] = <span class="built_in">find</span>(vec[root]);</span><br><span class="line">    <span class="keyword">return</span> vec[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并指将给定两个节点所在的集合合并为一个集合。在代码中通过将其中一个集合的根节点的父节点设置成另一个节点的根节点，这样两个集合就有了共同的根节点，即合并为同一个集合了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_root</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    vec[<span class="built_in">find</span>(r1)] = vec[<span class="built_in">find</span>(r2)];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-765-情侣牵手"><a href="#LeetCode-765-情侣牵手" class="headerlink" title="LeetCode 765. 情侣牵手"></a>LeetCode 765. 情侣牵手</h2><p><code>n</code> 对情侣坐在连续排列的 <code>2n</code> 个座位上，想要牵到对方的手。</p>
<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i</code> 个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2n-2, 2n-1)</code>。</p>
<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起。</em> 每次交换可选择任意两人，让他们站起来交换座位。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 只需要交换row[<span class="number">1</span>]和row[<span class="number">2</span>]的位置即可。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: row = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过观察我们可以发现：</p>
<ul>
<li><p>如果有 <code>2</code> 对情侣彼此坐错了位置，则需要进行 <code>1</code> 次交换。</p>
</li>
<li><p>如果有 <code>3</code> 对情侣彼此坐错了位置，则需要进行 <code>2</code> 次交换。</p>
</li>
<li><p>如果有 <code>4</code> 对情侣彼此坐错了位置，则需要进行 <code>3</code> 次交换。</p>
</li>
<li><p>如果有 <code>n</code> 对情侣彼此坐错了位置，则需要进行 <code>n-1</code> 次交换。</p>
</li>
</ul>
<p>那么我们可以采用并查集的数据结构，将彼此坐错的情侣放进同一个集合，记并查集森林中有 <code>cnt</code> 棵树，共有 <code>n</code> 对情侣，那么需要交换的次数就是 <code>n-cnt</code> 。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[root] != root) vec[root] = <span class="built_in">find</span>(vec[root]);</span><br><span class="line">        <span class="keyword">return</span> vec[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_root</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        vec[<span class="built_in">find</span>(r1)] = vec[<span class="built_in">find</span>(r2)];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.<span class="built_in">size</span>(); <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        vec.<span class="built_in">resize</span>(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) vec[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">union_root</span>(row[<span class="number">2</span> * i - <span class="number">2</span>] / <span class="number">2</span>, row[<span class="number">2</span> * i - <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(i) == i) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们用某个人的 <strong>ID</strong> 除以 <code>2</code> 来表示ta和ta对象共同的 <strong>情侣ID</strong>，然后把实际上挨着坐的人都 <code>union</code> 起来。如果他们本来就是情侣，则最终他们所在集合就只会有一个元素，表示这个集合中的人不需要交换。 <code>union</code> 到最后，我们得到的并查集中每个集合的情侣都坐混了，需要互相发生交换；而不同集合中的情侣之间则不需要发生交换。</p>
<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="速通《空洞骑士》"><a href="#速通《空洞骑士》" class="headerlink" title="速通《空洞骑士》"></a>速通《空洞骑士》</h2><p>这游戏很简单的，两个多小时就通关了(狗头)。</p>
<p><img src="https://cyclohexatriene.github.io/images/hk.png"></p>
<h2 id="没事听点歌（莫文蔚-这世界那么多人）"><a href="#没事听点歌（莫文蔚-这世界那么多人）" class="headerlink" title="没事听点歌（莫文蔚 - 这世界那么多人）"></a>没事听点歌（莫文蔚 - 这世界那么多人）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/这世界那么多人.mp3" type="audio/mpeg">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/06/28/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9-%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E5%BF%AB%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/28/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9-%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E5%BF%AB%E6%8E%92/" class="post-title-link" itemprop="url">快速选择 & 三向切分快排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-28 15:33:12" itemprop="dateCreated datePublished" datetime="2022-06-28T15:33:12+08:00">2022-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 19:33:59" itemprop="dateModified" datetime="2022-10-08T19:33:59+08:00">2022-10-08</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>标题这两个算法，一个是阉割版的快排，另一个是特殊优化过的快排。既然都跟快排有关系，那本文就从最基础的快速排序开始讲起吧。本文中提到的排序都将以升序为例。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一位叫 C. A. R. Hoare （中文名：霍尔）的强者发明的。</p>
<blockquote>
<p>1960年，霍尔在对俄语词典进行排序的过程中发明了这个算法，当时他才26岁。根据霍尔的自述：“解决词典排序时，我第一个想法是使用冒泡排序，但非常幸运的是，我第二个方法就想到了快速排序。”我们完全赞同他的自我评价：“我是幸运的，以发明一种新的排序方法开始一个人的计算机职业生涯实在是太美妙了！”——《算法设计与分析基础（第三版）》</p>
</blockquote>
<p>快速排序的中心思想是分治。每一轮排序中，选取一个基准数，把小于这个基准数的都放到数组的左边，把大于这个基准数的都放到数组的右边，然后把基准数放在二者的交界处。这样，我们就相当于把这个基准数放到了它排完序后该放的地方。然而此时这个数左边和右边的区间都还处于无序的状态，所以我们递归地对左右区间进行排序，最终使整个数组有序。平均而言，快速排序的时间复杂度是 <code>O(nlogn)</code> ，空间复杂度是 <code>O(logn)</code> ，但是最差的情况下，每次选取基准数时刚好是区间内的最大&#x2F;最小值（比如对一个降序数组进行升序排序），这样就需要递归 <code>n-1</code> 次。所以有写法为了尽量降低极端情况的影响，采用随机选择基准数的策略。而我比较习惯用Lomuto划分来写，就是选取区间左边第一个数作为基准数。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">int</span> i = left; <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[j] &gt;= nums[key] &amp;&amp; i &lt; j) j--;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &lt;= nums[key] &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[key], nums[i]);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面通过两个例题来介绍标题里的两个算法。</p>
<hr>
<h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h1><h2 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode 215. 数组中的第K个最大元素"></a>LeetCode 215. 数组中的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解 1"></a>题解 1</h1><p>这道题就是快速选择算法的经典应用场景了，它可以在 <code>O(n)</code> 的时间复杂度下找到这个数组第K大的数。我前面之所以说快速选择是阉割版的快速排序，是因为这两个算法的思路是一毛一样的，快速选择解决的问题可以说是快排的子问题。在快速排序中，每轮排序可以确定基准数在排序后数组中的位置，就相当于它的大小排序。例如在某一轮排序中，我们确定了基准数 <code>a</code> 是数组中第 <code>k&#39;</code> 大的数，那么：</p>
<ul>
<li><p>如果 <code>k&#39; = k</code> ，说明当前的基准数就是数组第 <code>k</code> 大的数。</p>
</li>
<li><p>如果 <code>k&#39; &lt; k</code> ，说明我们要找的数比当前的基准数要小一些，所以我们递归地在基准数左边的区间里继续查找，而右边的区间就可以放着不动了。</p>
</li>
<li><p>如果 <code>k&#39; &gt; k</code> ，说明我们要找的数比当前的基准数要大一些，所以我们递归地在基准数右边的区间里继续查找，而左边的区间就可以放着不动了。</p>
</li>
</ul>
<p>在理想情况下，我们每次可以将数组对半分，此时我们需要查找的次数最大是一个首项为 <code>n</code> ，项数为 <code>log₂n</code> ，公比为 <code>1/2</code> 的等比数列的和，即 <code>2n-2</code> 次，所以本算法的时间复杂度是 <code>O(n)</code> 。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l; <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &gt;= nums[l] &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &lt;= nums[l] &amp;&amp; i &lt; j) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l], nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == k) <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, i - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">partition</span>(nums, i + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 每轮排序时，要先减小 <code>j</code> 的值，再增大 <code>i</code> 的值，这样可以保证 <code>i</code> 和 <code>j</code> 重合时对应的值一定是小于 <code>key</code> 的，这样就可以拿 <code>key</code> 和 <code>nums[i]</code> 直接交换。</p>
<hr>
<h1 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h1><h2 id="LeetCode-324-摆动排序-II"><a href="#LeetCode-324-摆动排序-II" class="headerlink" title="LeetCode 324. 摆动排序 II"></a>LeetCode 324. 摆动排序 II</h2><p>给你一个整数数组 <code>nums</code>，将它重新排列成 <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code> 的顺序。</p>
<p>你可以假设所有输入数组都可以得到满足题目要求的结果。</p>
<h3 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 同样是符合题目要求的结果，可以被判题程序接受。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong> 使用 <code>O(n)</code> 时间复杂度或原地 <code>O(1)</code> 额外空间来实现。</p>
<hr>
<h1 id="题解-2"><a href="#题解-2" class="headerlink" title="题解 2"></a>题解 2</h1><p>在特殊情况下，待排序数组可能是一个有很多重复元素的数组，而常规的快排依然会进行 <code>logn</code> 次遍历。而三向切分则是快速排序针对此场景的优化方案，每轮排序把小于基准数的放左边，大于基准数的放右边，而等于基准数的全部汇总放中间，这样未排序的部分就可以大大缩小。</p>
<p>回到正题，本题最简单的解法就是先排个序，然后左边较小的部分和右边较大的部分穿插起来排。但是当数组中重复元素等于数组长度的一半时，就会出现两个相同的数字挨着的情况，这种情况不满足题设的严格大于&#x2F;小于。为了避免这种情况，我们可以将左子数组和右子数组逆序一下再穿插。</p>
<p>例如针对数组 <code>[1,1,2,2,2,3]</code> ，如果直接排序然后穿插的话，左子数组是 <code>[1,1,2]</code> ，右子数组是 <code>[2,2,3]</code> ，穿插后是 <code>[1,2,1,2,2,3]</code> ，不满足题目条件。而逆序后，左子数组就是 <code>[2,1,1]</code> ，右子数组就是 <code>[3,2,2]</code> ，穿插后是 <code>[2,3,1,2,1,2]</code> ，满足题目条件。这种算法的时间复杂度是 <code>O(nlogn)</code> 。</p>
<p>想要优化，就需要用到上面提到的三向切分快排了。稍加思索就能发现我们其实根本不需要保证两个子数组是有序的，只要能让可能挨着出现的数字一个在这头一个在那头就可以了。这个挨着出现的数字肯定是同时出现在左子数组和右子数组里的数字，而这种数字一定是数组的中位数。结合快速查找算法，我们可以预先查到这个数组的中位数是多少，然后再用三向切分的思想把中位数全部集中到数组中间，这时再把数组从中间切开穿插排列，就可以得到题目要求的数组了。</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">QuickSelect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l; <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] &gt;= nums[l] &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &lt;= nums[l] &amp;&amp; i &lt; j) i++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l], nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == k) <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; k) <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums, l, i - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">QuickSelect</span>(nums, i + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">QuickSelect</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="keyword">int</span> right = n - <span class="number">1</span>; <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (mid &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[mid], nums[left]);</span><br><span class="line">                left++;</span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; key) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[mid], nums[right]);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = n - n / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp1</span><span class="params">(nums.begin(), nums.begin() + m)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp2</span><span class="params">(nums.begin() + m, nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp1.<span class="built_in">size</span>(); i++) nums[i * <span class="number">2</span>] = temp1[temp1.<span class="built_in">size</span>() - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp2.<span class="built_in">size</span>(); i++) nums[i * <span class="number">2</span> + <span class="number">1</span>] = temp2[temp2.<span class="built_in">size</span>() - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，快速选择找到的中位数是后面三向切分的基准数。由于三向切分只进行了一轮，所以时间复杂度是 <code>O(n)</code> ，而快速选择的时间复杂度是 <code>O(n)</code> ，所以整个算法的时间复杂度也是 <code>O(n)</code> 。</p>
<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><h2 id="在学Linux"><a href="#在学Linux" class="headerlink" title="在学Linux"></a>在学Linux</h2><p>开始学Linux了，没有闲置的设备就在电脑里装了虚拟机。每次从Linux回到Windows都有一种如释重负的轻松的感觉，刚开始转换操作系统真别扭。但是在Shell里敲指令还是很带感的！</p>
<p><img src="https://cyclohexatriene.github.io/images/linux.png"></p>
<h2 id="放暑假了"><a href="#放暑假了" class="headerlink" title="放暑假了"></a>放暑假了</h2><p>19号就考完了，24号交了论文之后就正式开始暑假了。看大家的去向，好多人都找了实习，而我暑假除了社会调查的作业以外剩下的时间都能自己安排。这个暑假是这辈子过的最长的暑假了，接近三个月。要好好珍惜最后的闲暇了，退休前是不可能再有这么长的空闲了。在这里立一些暑期flag，也不追求全部都能完成，能认真地做完一两项都是好的，就是希望能好好利用这个暑假吧。</p>
<ul>
<li><p>《鸟哥的Linux私房菜 基础学习篇》</p>
</li>
<li><p>《计算机网络 自顶向下方法》</p>
</li>
<li><p>学习数据库和SQL的相关知识</p>
</li>
<li><p>《STL源码剖析》</p>
</li>
<li><p>找一些实战项目练练手</p>
</li>
<li><p>LeetCode坚持刷题，每日一题的基础上再加练</p>
</li>
</ul>
<p>暂时就想到这些。8说了，开卷！</p>
<h2 id="没事听点歌（Jam-七月上）"><a href="#没事听点歌（Jam-七月上）" class="headerlink" title="没事听点歌（Jam - 七月上）"></a>没事听点歌（Jam - 七月上）</h2><audio controls>
    <source src="https://cyclohexatriene.github.io/music/七月上.mp3" type="audio/mpeg">
</audio>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2022/06/06/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0-%E2%91%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0-%E2%91%A0/" class="post-title-link" itemprop="url">线段树复习 ①</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-06 17:25:46 / 修改时间：20:09:26" itemprop="dateCreated datePublished" datetime="2022-06-06T17:25:46+08:00">2022-06-06</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>线段树实在是太难了，今天又做到一题，已经完全想不起来怎么做了，所以复习了一下。以后每次做到又不会了就复习一下，把例题收录进来。不喜欢背代码模板，就把这次悟到的用文字描述一下吧。</p>
<h2 id="修改函数-update"><a href="#修改函数-update" class="headerlink" title="修改函数 update()"></a>修改函数 update()</h2><ul>
<li><p>需要六个参数，其中两个表示待查找的区间的左右边界，两个表示当前查找到的区间的左右边界（初始值为整棵线段树的左界和右界），一个表示当前节点的下标，最后一个表示需要修改的值（下面这道题中需要修改的值固定为 <code>1</code> ，所以可以省去一个参数）。</p>
</li>
<li><p>如果当前区间和待查找区间不重叠，则直接返回。</p>
</li>
<li><p>如果当前区间被待查找区间完全包含，则修改本节点的值后为当前节点打下一个 lazytag ，表示这个节点后的所有节点都要加上 lazytag 的值。</p>
</li>
<li><p>如果当前区间和待查找区间只有部分重叠，则将当前区间一分为二，并递归地进行搜索，相当于搜索当前节点的左右两个子节点。<strong>递归搜索完毕后，用两个子节点的值更新当前节点的值。</strong></p>
</li>
</ul>
<p>别的暂时还没什么更深入的理解，下次再更新。</p>
<hr>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LeetCode-732-我的日程安排表-III"><a href="#LeetCode-732-我的日程安排表-III" class="headerlink" title="LeetCode 732. 我的日程安排表 III"></a>LeetCode 732. 我的日程安排表 III</h2><p>当 <code>k</code> 个日程安排有一些时间上的交叉时（例如 <code>k</code> 个日程安排都在同一时间内），就会产生 <code>k</code> 次预订。</p>
<p>给你一些日程安排 <code>[start, end)</code> ，请你在每个日程安排添加后，返回一个整数 <code>k</code> ，表示所有先前日程安排会产生的最大 <code>k</code> 次预订。</p>
<p>实现一个 <code>MyCalendarThree</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>
<ul>
<li><p><code>MyCalendarThree()</code> 初始化对象。</p>
</li>
<li><p><code>int book(int start, int end)</code> 返回一个整数 <code>k</code>，表示日历中存在的 <code>k</code> 次预定的最大值</p>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyCalendarThree&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>]</span><br><span class="line">[[], [<span class="number">10</span>, <span class="number">20</span>], [<span class="number">50</span>, <span class="number">60</span>], [<span class="number">10</span>, <span class="number">40</span>], [<span class="number">5</span>, <span class="number">15</span>], [<span class="number">5</span>, <span class="number">10</span>], [<span class="number">25</span>, <span class="number">55</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyCalendarThree myCalendarThree = <span class="keyword">new</span> <span class="built_in">MyCalendarThree</span>();</span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。</span></span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">50</span>, <span class="number">60</span>); <span class="comment">// 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。</span></span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">10</span>, <span class="number">40</span>); <span class="comment">// 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。</span></span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">5</span>, <span class="number">15</span>); <span class="comment">// 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。</span></span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 返回 3</span></span><br><span class="line">myCalendarThree.<span class="built_in">book</span>(<span class="number">25</span>, <span class="number">55</span>); <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于本题 <code>start</code> 和 <code>end</code> 的数据范围很大，所以如果像之前那样暴力开 <code>4</code> 倍内存的话内存会溢出。所以本题中可以用哈希表来代替数组。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tree;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lazy;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; r || end &lt; l) <span class="keyword">return</span>;<span class="comment">//如果当前处理范围在需要计算的范围之外，则直接返回。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="comment">//如果当前处理范围被需要计算的范围完全包括，则将整个节点打上一个lazytag，并将节点值加一。</span></span><br><span class="line">            tree[node]++;</span><br><span class="line">            lazy[node]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> leftnode = node * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> rightnode = node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">update</span>(start, end, l, mid, leftnode);</span><br><span class="line">            <span class="built_in">update</span>(start, end, mid + <span class="number">1</span>, r, rightnode);</span><br><span class="line">            tree[node] = lazy[node] + <span class="built_in">max</span>(tree[leftnode], tree[rightnode]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCalendarThree</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(start, end - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1e9</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> tree[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>代码中，用 <code>start</code> 和 <code>end</code> 表示待处理的区间，用<code>l</code> 和 <code>r</code> 表示当前处理的区间。在刚开始阅读这段代码的时候我很奇怪为什么一开始打上 lazytag 的时候 node 的值已经加上一了，后面重新计算的时候还要再加 lazytag 的值，后来发现每个 node 储存的值是区间的最大值，而重新计算 node 值时它的 leftnode 和 rightnode 是没有把 lazytag 的值算上的，所以要重新加上一遍。</p>
<hr>
<h1 id="有的没的"><a href="#有的没的" class="headerlink" title="有的没的"></a>有的没的</h1><p>忙着干活，没空写了，下次一定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="环己三烯"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">环己三烯</p>
  <div class="site-description" itemprop="description">万里长征人未还</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">环己三烯</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'UsSNtA9GJ5h8tGViWaV97qbO-9Nh9j0Va',
      appKey     : 'J83xwqE3YCKgWOy0dIBrad1s',
      placeholder: "莫西莫西？",
      avatar     : 'hide',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://ussnta9g.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
