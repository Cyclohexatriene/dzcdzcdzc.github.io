<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cyclohexatriene.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. 聊一聊智能指针智能指针的作用是管理一个指针，避免申请的空间忘记释放导致内存泄漏。智能指针本质上是一个类模板，当超出了类的作用域时，类就会自动调用析构函数回收资源。C++里有四种智能指针：auto_ptr, unique_ptr, shared_ptr,和weak_ptr，其中auto_ptr 在C++11版本已经被废弃。  auto_ptr （已废弃）  auto_ptr 采用了所有权模式，">
<meta property="og:type" content="article">
<meta property="og:title" content="腾讯（魔方工作室）一面面经">
<meta property="og:url" content="http://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="环己三烯的冬眠舱">
<meta property="og:description" content="1. 聊一聊智能指针智能指针的作用是管理一个指针，避免申请的空间忘记释放导致内存泄漏。智能指针本质上是一个类模板，当超出了类的作用域时，类就会自动调用析构函数回收资源。C++里有四种智能指针：auto_ptr, unique_ptr, shared_ptr,和weak_ptr，其中auto_ptr 在C++11版本已经被废弃。  auto_ptr （已废弃）  auto_ptr 采用了所有权模式，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cyclohexatriene.github.io/images/virtual-func.jpg">
<meta property="article:published_time" content="2023-03-09T16:07:43.000Z">
<meta property="article:modified_time" content="2023-03-09T16:08:08.217Z">
<meta property="article:author" content="环己三烯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cyclohexatriene.github.io/images/virtual-func.jpg">

<link rel="canonical" href="http://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>腾讯（魔方工作室）一面面经 | 环己三烯的冬眠舱</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">环己三烯的冬眠舱</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">天天网抑云，偶尔读点书。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-comment-board">

    <a href="/comment-board" rel="section">留言板</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cyclohexatriene.github.io/2023/03/10/%E8%85%BE%E8%AE%AF%EF%BC%88%E9%AD%94%E6%96%B9%E5%B7%A5%E4%BD%9C%E5%AE%A4%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="环己三烯">
      <meta itemprop="description" content="万里长征人未还">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="环己三烯的冬眠舱">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          腾讯（魔方工作室）一面面经
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-10 00:07:43 / 修改时间：00:08:08" itemprop="dateCreated datePublished" datetime="2023-03-10T00:07:43+08:00">2023-03-10</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-聊一聊智能指针"><a href="#1-聊一聊智能指针" class="headerlink" title="1. 聊一聊智能指针"></a>1. 聊一聊智能指针</h3><p>智能指针的作用是管理一个指针，避免申请的空间忘记释放导致内存泄漏。智能指针本质上是一个类模板，当超出了类的作用域时，类就会自动调用析构函数回收资源。C++里有四种智能指针：<code>auto_ptr</code>, <code>unique_ptr</code>, <code>shared_ptr</code>,和<code>weak_ptr</code>，其中<code>auto_ptr</code> 在C++11版本已经被废弃。</p>
<ul>
<li><code>auto_ptr</code> （已废弃）</li>
</ul>
<p><code>auto_ptr</code> 采用了所有权模式，后创建的指针会剥夺前面的指针的所有权。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></tbody></table></figure>

<p>p2会剥夺p1对指针的所有权，此时再访问p1就会出错。所以<code>auto_ptr</code>存在潜在的内存崩溃问题。</p>
<ul>
<li><code>unique_ptr</code> （代替<code>auto_ptr</code>）</li>
</ul>
<p><code>unique_ptr</code>采用独占式拥有概念，保证同一时间内之有一个智能指针可以指向该对象。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = p1;</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码无法通过编译，保证在编译期就将问题排查出来。此外，<code>unique_ptr</code>允许被一个临时的右值赋值，例如将上述第二行代码改为<code>p2 = unique_ptr&lt;int&gt;(new int(1))</code>，则可以通过编译，因为这样不会造成悬挂指针的情况。</p>
<ul>
<li><code>shared_ptr</code></li>
</ul>
<p><code>shared_ptr</code>采用共享式拥有概念，多个<code>shared_ptr</code>可以指向相同的对象，并且只有最后一个指向它的<code>shared_ptr</code>被销毁时才会释放它占有的资源。</p>
<ul>
<li><code>weak_ptr</code></li>
</ul>
<p><code>weak_ptr</code>是为了避免两个<code>shared_ptr</code>互相引用，导致其计数永远不会归零、资源永远不会被释放的死锁现象而引入的。它不控制对象的生命周期，不会改变计数器。<code>weak_ptr</code>没有重载<code>*</code>和<code>-&gt;</code>运算符，所以不能直接访问和修改引用的对象（可以通过<code>lock()</code>函数将其转化为<code>shared_ptr</code>然后再访问），但可以访问对象的引用数量等信息，它更像是一个<code>shared_ptr</code>的监控者。</p>
<h3 id="2-能不能自己实现一个shared-ptr？"><a href="#2-能不能自己实现一个shared-ptr？" class="headerlink" title="2. 能不能自己实现一个shared_ptr？"></a>2. 能不能自己实现一个<code>shared_ptr</code>？</h3><p>自己封装一个类模板就行。需要实现构造函数和析构函数、拷贝构造函数和拷贝赋值函数，还有重载一些指针的操作符。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_cnt</span> {</span></span><br><span class="line"><span class="comment">//计数器类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">shared_cnt</span>() :<span class="built_in">cnt</span>(<span class="number">1</span>) {}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">		cnt++;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>{</span><br><span class="line">		cnt--;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* ptr;</span><br><span class="line">	shared_cnt* cb;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数和析构函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(T* p = <span class="literal">NULL</span>) {</span><br><span class="line">		ptr = p;</span><br><span class="line">		cb = <span class="keyword">new</span> <span class="built_in">shared_cnt</span>();</span><br><span class="line">	}</span><br><span class="line">	~<span class="built_in">my_shared_ptr</span>() {</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">"deleted."</span> &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针操作</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> {</span><br><span class="line">		<span class="keyword">return</span> *ptr;</span><br><span class="line">	}</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> {</span><br><span class="line">		<span class="keyword">return</span> ptr; <span class="comment">// p-&gt;m被解释为(p.operator-&gt;())-&gt;m，所以返回值应该是一个指针。</span></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	}</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) {</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> a) <span class="keyword">const</span> {</span><br><span class="line">		<span class="keyword">return</span> ptr[a];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">my_shared_ptr</span>(<span class="keyword">const</span> my_shared_ptr&amp; other) {</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 赋值函数</span></span><br><span class="line">	my_shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> my_shared_ptr&amp; other) {</span><br><span class="line">		cb-&gt;<span class="built_in">reduce</span>();</span><br><span class="line">		<span class="keyword">if</span> (cb-&gt;<span class="built_in">getCnt</span>() == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">delete</span> ptr;</span><br><span class="line">			<span class="keyword">delete</span> cb;</span><br><span class="line">			cout &lt;&lt; <span class="string">"old ptr has been deleted."</span> &lt;&lt; endl;</span><br><span class="line">		}</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">		cb = other.cb;</span><br><span class="line">		cb-&gt;<span class="built_in">add</span>();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> cb-&gt;<span class="built_in">getCnt</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-虚函数是什么原理？"><a href="#3-虚函数是什么原理？" class="headerlink" title="3. 虚函数是什么原理？"></a>3. 虚函数是什么原理？</h3><p>每个包含虚函数的类（或者继承了包含虚函数的基类）都有一个自己的虚函数表，这个表是一个编译时就确定的静态数组。虚函数表包含了指向每个虚函数的函数指针。而编译器会在基类中定义一个隐藏的指针<code>vptr</code>，这是一个指向虚函数表的指针，在类对象创建的时候<code>vptr</code> 会设置成指向类的虚函数表。所以含有虚函数的类会多分配一个指针的大小。如果子类重写了基类的虚函数，就会将虚函数表中的函数指针覆盖为自己重写的函数以供调用。</p>
<p>如以下例子所示，基类<code>Base</code>有<code>function1</code>和<code>function2</code>两个函数，子类<code>D1</code>和<code>D2</code>分别重写了这两个函数。所以在<code>D1</code>的对象的虚函数表中，<code>function1</code>会指向自己重写的新函数，而<code>function2</code>会指向基类的<code>function2</code>，<code>D2</code>同理。</p>
<img src="https://cyclohexatriene.github.io/images/virtual-func.jpg">

<p>还有一个很巧妙的事情。看下面的代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D1 d1;</span><br><span class="line">Base *dPtr = &amp;d1;</span><br></pre></td></tr></tbody></table></figure>

<p>因为 <code>dPtr</code> 是 <code>Base</code> 类型指针，它只指向 <code>d1</code> 对象的 <code>Base</code> 类型部分(即，指向 <code>d1</code> 对象中的 <code>Base</code> 子对象)，而  <code>vptr</code> 也在 <code>Base</code> 类型部分。所以 <code>dPtr</code> 可以访问 <code>Base</code> 类型部分中的 <code>vptr</code> 。同时，这里注意，  <code>dPtr-&gt;__vptr</code> 指向的是 <code>D1</code> 的虚拟函数表，这是在 <code>d1</code> 初始化时就确定的。所以结果，尽管 <code>dPtr</code> 是 <code>Base</code>  类型指针，但它能够访问 <code>D1</code> 的虚函数表。</p>
<p>所以当调用<code>dPtr-&gt;function1()</code>时，发生了这些事情：</p>
<ol>
<li>程序识别到<code>function1()</code>是一个虚函数。</li>
<li>程序使用 <code>dPtr-&gt;__vptr</code> 获取到了 <code>D1</code> 的虚函数表。</li>
<li>它在 <code>D1</code> 的虚函数表中寻找可以调用的 <code>function1() </code>版本，这里是 <code>D1::function1()</code>。</li>
<li>所以这次调用实际调用的就是<code>D1::function1()</code>。</li>
</ol>
<h3 id="4-含有虚函数的类的size问题？"><a href="#4-含有虚函数的类的size问题？" class="headerlink" title="4. 含有虚函数的类的size问题？"></a>4. 含有虚函数的类的size问题？</h3><ul>
<li>如果类里只有一个虚函数，那这个类有多大？</li>
</ul>
<p>只要有虚函数就会创建一个虚表指针，一个指针是4字节，所以这个类就是4字节。</p>
<ul>
<li>那要是有两个虚函数呢？</li>
</ul>
<p>那也是只有一个虚表指针，还是4字节。</p>
<ul>
<li>扩展：类的内存布局</li>
</ul>
<p>在没有继承的情况下，类的内存布局会根据声明顺序依次排布，且会有对齐现象，默认对齐大小为类内最大的基础类型大小。成员函数存在代码区，不占类的内存。静态变量存在全局存储区，也不占类的内存。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>此时A对象的<code>short a</code>本来占两个字节，为了与<strong>最大的基础类型</strong><code>int</code>对齐，接下来的2字节将会跳过，然后是<code>int b</code>的4字节，一共是8字节。如果将<code>func1</code>设置成虚函数，则会在类的头部出现一个虚表指针，那么A就是12字节。</p>
<p>虚函数表会单独对齐，例如，将<code>b</code>改为<code>double</code>类型，类内存的布局就是：4字节虚表指针，4字节对齐，2字节<code>short a</code>，6字节对齐，然后是8字节的<code>double b</code>，一共是24字节。</p>
<ul>
<li>一个空类是多大？</li>
</ul>
<p>一个空类理论上来说是0字节，但是编译器会为其加入1字节，这是为了它的每个对象都有独一无二的地址。例如对象a的地址是0x00000000，那对象b的地址就不可能再是0x00000000，起码也是0x00000001，这就意味着对象a占据了1字节的空间。 当另一个类继承了这个空类时，这个空类的内存就变回0字节了。</p>
<h3 id="5-虚函数和纯虚函数的区别？"><a href="#5-虚函数和纯虚函数的区别？" class="headerlink" title="5. 虚函数和纯虚函数的区别？"></a>5. 虚函数和纯虚函数的区别？</h3><p>虚函数由基类定义一个默认的函数，子类在继承时可以重写一个自己专属版本，也可以直接采用基类的默认函数；而纯虚函数则由基类给出声明，子类<strong>必须</strong>自行完成定义。含有纯虚函数的类被称作抽象类，无法直接创建实例，需要被继承后创建子类的实例。</p>
<h3 id="6-你的项目里用到了大量的锁，有什么优化方式吗？"><a href="#6-你的项目里用到了大量的锁，有什么优化方式吗？" class="headerlink" title="6. 你的项目里用到了大量的锁，有什么优化方式吗？"></a>6. 你的项目里用到了大量的锁，有什么优化方式吗？</h3><p>我的回答：我目前是获得一次锁只从队列中获取一个任务，可以设计成获得一次锁就从队列里获取若干个任务一起处理，这样可以均摊锁的成本。</p>
<h3 id="7-有没有可能完全不用锁？"><a href="#7-有没有可能完全不用锁？" class="headerlink" title="7. 有没有可能完全不用锁？"></a>7. 有没有可能完全不用锁？</h3><p>我的回答：可以加一层代理，由一个线程统一对任务队列进行管理，接到任务时主动指定某个线程并将其唤醒处理，不使用锁的机制抢任务处理。</p>
<h3 id="8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"><a href="#8-你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？" class="headerlink" title="8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？"></a>8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？</h3><p>我的回答：不是很了解，可以加密，传输密文，或改用HTTPS。</p>
<h3 id="9-那你知道HTTPS的原理吗？"><a href="#9-那你知道HTTPS的原理吗？" class="headerlink" title="9. 那你知道HTTPS的原理吗？"></a>9. 那你知道HTTPS的原理吗？</h3><p>有点长，回头再来学。</p>
<h3 id="10-你知道内存分配的方式吗？比如malloc-jemalloc之类的"><a href="#10-你知道内存分配的方式吗？比如malloc-jemalloc之类的" class="headerlink" title="10. 你知道内存分配的方式吗？比如malloc/jemalloc之类的"></a>10. 你知道内存分配的方式吗？比如malloc/jemalloc之类的</h3><p>我的回答：只知道malloc，但知道操作系统级别的内存分配方式，面试官让我展开说说，我就说了一些操作系统的内存管理方式，比如说连续静态分配、动态分区、分页式之类的。追问如何减少碎片</p>
<ul>
<li><p><code>malloc(size_t size)</code>：C/C++标准库的函数，分配<code>size</code>字节的内存，返回所分配区域的第一个字节的指针，如果内存不够就返回NULL。不会对空间进行初始化。 </p>
</li>
<li><p><code>calloc(size_t num, size_t size)</code>：为一个大小是<code>num</code>的数组分配内存，每个元素的大小是<code>size</code>，返回指向所分配区域的第一个字节的指针。如果内存不够就返回NULL。每个元素会被初始化为0。</p>
</li>
<li><p><code>alloca(size_t size)</code>：在栈上申请内存，不需要free函数释放。很快，适合小的分配。但是可移植性差，不推荐使用。</p>
</li>
<li><p><code>tcmalloc</code>：google的内存分配管理模块</p>
</li>
<li><p><code>jemalloc</code>：BSD的内存分配管理模块</p>
</li>
</ul>
<h3 id="11-HTTP报文由哪些结构组成？消息报头都有哪些字段？"><a href="#11-HTTP报文由哪些结构组成？消息报头都有哪些字段？" class="headerlink" title="11. HTTP报文由哪些结构组成？消息报头都有哪些字段？"></a>11. HTTP报文由哪些结构组成？消息报头都有哪些字段？</h3><p><strong>请求报文：</strong></p>
<ol>
<li><p>请求行（请求方法、URL、HTTP版本）</p>
</li>
<li><p>请求头部（客户端信息、目标Host、需求语言等信息）</p>
</li>
<li><p>空行</p>
</li>
<li><p>请求数据（POST的信息）</p>
</li>
</ol>
<p><strong>响应报文：</strong></p>
<ol>
<li><p>状态行（HTTP版本、状态码）</p>
</li>
<li><p>消息报头（必备Content-Type和Content-Length，还有服务器信息、文件最后更新时间、压缩算法等）</p>
</li>
<li><p>空行</p>
</li>
<li><p>响应正文（HTML代码、图片数据等）</p>
</li>
</ol>
<h3 id="12-HTTP状态码有哪些？"><a href="#12-HTTP状态码有哪些？" class="headerlink" title="12. HTTP状态码有哪些？"></a>12. HTTP状态码有哪些？</h3><ol>
<li><p>信息响应，以1开头。例如<code>100 Continue</code>，POST方法可能会将请求头和请求数据分成两个数据包进行发送，服务器收到请求头时就会先响应一个<code>100 Continue</code>表示请求头没有问题，可以继续发请求数据。</p>
</li>
<li><p>成功响应，以2开头。例如<code>200 OK</code>。</p>
</li>
<li><p>重定向消息，以3开头。例如<code>301 Moved Permanently</code>，表示请求资源的URL已被永久更改，会在响应中给出新的URL。还有<code>307 Temporary Redirect</code>和<code>308 Permanent Redirect</code>等。</p>
</li>
<li><p>客户端错误响应，以4开头，例如<code>400 Bad Request</code>、<code>403 Forbidden</code>、<code>404 Not Found</code></p>
</li>
<li><p>服务端错误响应，以5开头，例如<code>502 Bad Gateway</code>、<code>503 Service Unavailable</code>等。</p>
</li>
</ol>
<h3 id="13-Linux环境下，程序出错，错误信息会记录在什么文件里？"><a href="#13-Linux环境下，程序出错，错误信息会记录在什么文件里？" class="headerlink" title="13. Linux环境下，程序出错，错误信息会记录在什么文件里？"></a>13. Linux环境下，程序出错，错误信息会记录在什么文件里？</h3><p>我答了个errno，面试官指出这是系统调用的错误信息；我说那我不知道了，我只见过stdout的错误信息，比如段错误之类的；面试官追问，那除了段错误还有什么呢，我回忆了一下说不知道了（其实还有算术错误，比如分母为0、无对应操作符、返回值类型有误、未定义变量/函数、类型溢出等等）。</p>
<p>会存放在core文件里，可以使用gdb打开core文件（指令为<code>gdb [exec file]] [core file]</code>，例如 <code>gdb ./a.o ./core</code>）。指定core文件进入gdb后，gdb会自动显示如下的错误信息，包括错误的类型、出错的线程、代码所在行以及具体是哪句代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Core was generated by `./a.o'.</span><br><span class="line">Program terminated with signal SIGFPE, Arithmetic exception.</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">24     cout &lt;&lt; 1/a &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>

<p>也可以使用<code>where</code>和<code>bt</code>指令查看，但不会显示出具体的代码。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) where</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x000055f9f4f5db7b in main () at ./a.cpp:24</span><br></pre></td></tr></tbody></table></figure>

<p><strong>备注：</strong></p>
<ol>
<li>使用<code>ulimit -c</code>查看core文件的最大大小，如果是0则不会生成core文件。如果指定文件大小，但生成的信息超过此大小，就会被裁剪而生成不完整的core文件，在调试此文件时gdb会提示错误。一般直接设置成<code>ulimit -c unlimited</code>就可以了。</li>
<li>如果要查看具体出错在哪行，使用g++编译时要加上<code>-g</code>获取调试信息，否则只会显示在哪个线程出错。</li>
<li>core文件的生成路径记录在<code>/proc/sys/kernel/core_pattern</code>这个文件里。</li>
</ol>
<h3 id="14-手撕代码"><a href="#14-手撕代码" class="headerlink" title="14. 手撕代码"></a>14. 手撕代码</h3><p>给定一个正整数N，打印出比N大的最小的“非重复数”（相邻数位不同，例如1120是重复数，1210是非重复数）。</p>
<p>测试用例：19901, 9901, 1120, 9</p>
<p><strong>思路：</strong>找到最高位的相邻数位相同的位置，对其进行处理（变得更大,必要时进位），剩下的用010101…填充即可。</p>
<p><strong>问题：</strong>如果使用测试用例219901，在一次进位后会变成22开头的数字，需要第二次进位。试图以循环方式处理，被面试官称为“缝缝补补”，很不优雅。</p>
<p><strong>解决方案：</strong>从右往左遍历，每扫到重复的就进行一次增加处理，直到全部相邻数位都不重复</p>
<p><strong>进阶：</strong>不使用string。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sin = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line">	num++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newNum = num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> newSin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num) {</span><br><span class="line">		<span class="keyword">if</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">			<span class="keyword">do</span> {</span><br><span class="line">				num++;</span><br><span class="line">			} <span class="keyword">while</span> ((num - num / <span class="number">10</span>) % <span class="number">10</span> == <span class="number">0</span>);</span><br><span class="line">		newNum = num;</span><br><span class="line">			newSin = sin;</span><br><span class="line">		}</span><br><span class="line">		num /= <span class="number">10</span>;</span><br><span class="line">		sin++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; newNum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newSin; i++) {</span><br><span class="line">		cout &lt;&lt; i % <span class="number">2</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="DLC-1-对象切片"><a href="#DLC-1-对象切片" class="headerlink" title="DLC.1 对象切片"></a>DLC.1 对象切片</h3><p><strong>对象切片：</strong>当一个函数的参数是<strong>按值传递</strong>的，且传递的对象类型是<strong>基类</strong>。当调用该函数时，传入派生类对象时，会自动向上转型，将对象转换成基类对象，并删除派生类中新增的任何成员。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v){}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is A"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2){}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is B"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A a)</span> </span>{</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">114</span>, <span class="number">514</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    A a = b;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">114</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"addr of a: "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"addr of b: "</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这段代码的输出是</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">addr of a: 010FF778</span><br><span class="line">addr of b: 010FF788</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br><span class="line">this is A</span><br></pre></td></tr></tbody></table></figure>

<p>由此可见，<code>A a = b</code>这句代码中发生了对象切片。因为这里创建了一个新的A类对象，自然就创建了新的A类的虚表指针，指向基类的函数。但是注意，<strong>如果传递指针，则不会发生对象切片</strong>，因为没有调用类的构造函数，只是一个指针的复制或拷贝过程，例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v):<span class="built_in">a</span>(v){}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is A"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2):<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2){}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is B"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>{</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    A* a = b;</span><br><span class="line">    A* a1 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114</span>);</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">    a1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"addr of a: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"addr of b: "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line">    <span class="built_in">p</span>(a1);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码输出是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br><span class="line">addr of a: 00D809E8</span><br><span class="line">addr of b: 00D809E8</span><br><span class="line">this is B</span><br><span class="line">this is B</span><br><span class="line">this is A</span><br></pre></td></tr></tbody></table></figure>

<p>只有新创建的a1对象调用了基类的函数。</p>
<h3 id="DLC-2-静态联编和动态联编"><a href="#DLC-2-静态联编和动态联编" class="headerlink" title="DLC.2 静态联编和动态联编"></a>DLC.2 静态联编和动态联编</h3><p><strong>联编：</strong>将源代码中的函数调用解释为执行特定的函数代码块的过程称为函数名联编。意思就是，同一个名称的函数有多种，联编就是把调用和具体的实现进行链接映射的操作。</p>
<p>联编中，C++编译器在编译过程中完成的编译叫做<strong>静态联编</strong>。</p>
<p>但是重载、重写、虚函数使得静态联编变得困难。因为编译器不知道用户将选择哪种类型的对象，执行具体哪一块代码。所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这个过程被称为<strong>动态联编</strong>。</p>
<p><strong>编译器对非虚方法使用静态联编，对虚方法使用动态联编。</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> v) :<span class="built_in">a</span>(v) {}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is A"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"function A"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) :<span class="built_in">A</span>(v1), <span class="built_in">b</span>(v2) {}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"this is B"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"function B"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(A* a)</span> </span>{</span><br><span class="line">    a-&gt;<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* a)</span> </span>{</span><br><span class="line">    a-&gt;<span class="built_in">f</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">114514</span>);</span><br><span class="line">    B* b = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">p</span>(a);</span><br><span class="line">    <span class="built_in">p</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">    <span class="built_in">f</span>(b);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码运行的结果是：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this is A</span><br><span class="line">this is B</span><br><span class="line">function A</span><br><span class="line">function A</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，编译器对虚函数进行了动态联编，分别调用了基类和子类的函数；而对非虚函数进行了静态联编，总是调用基类的函数。</p>
<h3 id="DLC-3-公有、保护、私有继承"><a href="#DLC-3-公有、保护、私有继承" class="headerlink" title="DLC.3 公有、保护、私有继承"></a>DLC.3 公有、保护、私有继承</h3><p>继承时，我们要选择继承方式，例如：<code>class B : public A</code>就是B以公有继承的方式继承了A。</p>
<p>而这个<code>public</code>修饰的是从类A继承来的对象在B里的新权限。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>如果类B对其进行<strong>公有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为公有对象。</p>
<p>如果类B对其进行<strong>保护继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为保护对象；<code>c</code>被继承为保护对象。</p>
<p>如果类B对其进行<strong>私有继承</strong>：<code>a</code>为A类私有，无法继承；<code>b</code>被继承为私有对象；<code>c</code>被继承为私有对象。</p>
<p><strong>规律：</strong>以最严格的权限为准。</p>
<h3 id="DLC-4-类和结构体的区别"><a href="#DLC-4-类和结构体的区别" class="headerlink" title="DLC.4 类和结构体的区别"></a>DLC.4 类和结构体的区别</h3><p>在C的时代，struct不能包含函数。</p>
<p>但是在C++时代，struct不仅可以包含函数，还可以包含虚函数、可以继承和多态、可以使用模板，甚至跟class可以互相继承，几乎和class没有区别。C++保留struct的一大原因（甚至可能是唯一原因）就是为了兼容C。</p>
<p>但是区别还是有的。</p>
<ol>
<li>struct的成员默认是public；class的成员默认是private。</li>
<li>struct默认是公有继承；class默认是私有继承。默认继承方式以子类为准。</li>
<li>struct不能定义模板参数，class可以（就像typename）。</li>
</ol>
<p>还有一个细节共同点：struct和class如果定义了构造函数，就都不能用大括号初始化（<code>A a{5};</code>），如果没定义构造函数，<strong>且成员变量都是公有的</strong>，就可以使用大括号初始化。</p>
<hr>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>牛客网 C++面经</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356879347">C++ | 虚函数表及虚函数执行原理详解</a></p>
<p><a herf="https://zhuanlan.zhihu.com/p/354849447">C++手把手带你实现一个智能指针</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380147337">浅析C++类的内存布局</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105714609">C/C++内存分配函数差异及高效率内存分配库总结</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应状态码</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135454697">GET 和 POST 的区别？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42570601/article/details/114842320">使用GDB(一)：分析core.xxx文件常用方法</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56104219/article/details/123244825">c++中的对象切片</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/scyq/p/12709629.html">C++ 动态联编和静态联编</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sxtdzj/article/details/81906504">C++公有继承，保护继承，私有继承的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alidada_blog/article/details/83419757">【C++】struct和class的区别</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/18/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Gin学习笔记">
      <i class="fa fa-chevron-left"></i> Gin学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/26/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/" rel="next" title="Spring Boot快速上手指南">
      Spring Boot快速上手指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%81%8A%E4%B8%80%E8%81%8A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">1. 聊一聊智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%83%BD%E4%B8%8D%E8%83%BD%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAshared-ptr%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2. 能不能自己实现一个shared_ptr？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">3. 虚函数是什么原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84size%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">4. 含有虚函数的类的size问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">5. 虚函数和纯虚函数的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E9%94%81%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">6. 你的项目里用到了大量的锁，有什么优化方式吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E5%AE%8C%E5%85%A8%E4%B8%8D%E7%94%A8%E9%94%81%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">7. 有没有可能完全不用锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%88%E4%BC%A0%E8%BE%93%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%98%E6%94%BE%EF%BC%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">8. 你的项目实现了注册和登录功能，如何保证（传输的过程和存放）的数据安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E9%82%A3%E4%BD%A0%E7%9F%A5%E9%81%93HTTPS%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">9. 那你知道HTTPS的原理吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F%E6%AF%94%E5%A6%82malloc-jemalloc%E4%B9%8B%E7%B1%BB%E7%9A%84"><span class="nav-number">10.</span> <span class="nav-text">10. 你知道内存分配的方式吗？比如malloc&#x2F;jemalloc之类的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-HTTP%E6%8A%A5%E6%96%87%E7%94%B1%E5%93%AA%E4%BA%9B%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%EF%BC%9F%E6%B6%88%E6%81%AF%E6%8A%A5%E5%A4%B4%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">11. HTTP报文由哪些结构组成？消息报头都有哪些字段？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12. HTTP状态码有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%87%BA%E9%94%99%EF%BC%8C%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E4%BC%9A%E8%AE%B0%E5%BD%95%E5%9C%A8%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E9%87%8C%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">13. Linux环境下，程序出错，错误信息会记录在什么文件里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81"><span class="nav-number">14.</span> <span class="nav-text">14. 手撕代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLC-1-%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87"><span class="nav-number">15.</span> <span class="nav-text">DLC.1 对象切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLC-2-%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="nav-number">16.</span> <span class="nav-text">DLC.2 静态联编和动态联编</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLC-3-%E5%85%AC%E6%9C%89%E3%80%81%E4%BF%9D%E6%8A%A4%E3%80%81%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-number">17.</span> <span class="nav-text">DLC.3 公有、保护、私有继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLC-4-%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.</span> <span class="nav-text">DLC.4 类和结构体的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reference"><span class="nav-number"></span> <span class="nav-text">reference</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="环己三烯"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">环己三烯</p>
  <div class="site-description" itemprop="description">万里长征人未还</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">环己三烯</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'UsSNtA9GJ5h8tGViWaV97qbO-9Nh9j0Va',
      appKey     : 'J83xwqE3YCKgWOy0dIBrad1s',
      placeholder: "莫西莫西？",
      avatar     : 'hide',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : 'https://ussnta9g.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
